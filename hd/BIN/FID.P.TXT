#A
_USESHIRES
#

PROGRAM KYANFID;

TYPE  FILENAME = ARRAY [1..64] OF CHAR; {fest!}
      KOPYNAME = ARRAY [1..64] OF CHAR; {fest!}

VAR   NAME0,   NAME1,    NAME2:   FILENAME;
      BANF,    BLEN,     FLEN:    INTEGER;
      BEFEHL,  ERRMLI,   ERRALL:  INTEGER;
      KSTR:    KOPYNAME; KERR:    INTEGER;

      AUSWAHL: ARRAY [1..12] OF CHAR;
      TASTE: CHAR; I: INTEGER;
{---------------------------------------}

PROCEDURE FID
 (VAR NAME0,  NAME1,  NAME2:  FILENAME;
  VAR BANF,   BLEN,   FLEN:   INTEGER;
  VAR BEFEHL, ERRMLI, ERRALL: INTEGER);

BEGIN
#A
IND EQU _T
MLI EQU $BF00
MLIDAT EQU $BF90
MLIUHR EQU $BF92
PRBYTE EQU $FDDA
;
; Sprung zum Parameter-Parse-ANFANG
; =================================
;
 JMP ANFANG
;
ORIG EQU *
ORIGL EQU >ORIG
FUELL DS 256-ORIGL
BPUF DS $0400
DPUF DS $0200
;
;-------------------------------------
; Zusaetzliche Labels fuer Copy-Befehl
; am Ende von FID
;
BPUFRD EQU BPUF
BPUFWR DS  $0400
PUFBEG EQU $2000  ;$2000 bis $3FFF
PUFFER EQU DPUF
;------------------------------------
;
NOM0 DB $00
ASCII0 DS 66
NOM1 DB $00
ASCII1 DS 64
NOM2 DB $00
ASCII2 DS 64
BANF DB $00
 DB $00
BLEN DB $00
 DB $00
FLEN DB $00
 DB $00
BEFEHL DB $00
ERRMLI DB $00
ERRALL DB $00
;
; Hier PRODOS-Entry
; =================
;
ENTRY STA ASAV
 STX XSAV
 STY YSAV
;
; Block-Puffer wirklich auf Seitengrenze?
;
 LDA #>BPUF  ;Low-Byte
 CMP #0
 BEQ OKAY
 JMP $FF59 ;Abbruch durch Monitorsprung
;
OKAY LDA IND
 STA INDSAV
 LDA IND+1
 STA INDSAV+1
 LDA #$00
 STA ERRMLI
 STA ERRALL
 LDA BEFEHL
 CMP #$0B
 BCC ENTRY1
 LDA #$80
 STA ERRALL
 JMP EXIT
ENTRY1 ASL A 
 TAX
 LDA JMPTAB,X
 STA ENTRY2+1
 INX
 LDA JMPTAB,X
 STA ENTRY2+2
ENTRY2 JMP $FFFF
JMPTAB DW REBOOT
 DW ONLIN
 DW PREFX
 DW CAT
 DW CREAT
 DW DELET
 DW LKUNL
 DW LKUNL
 DW RENOM
 DW BSAV
 DW BLOD
EXIT LDA ERRMLI
 BEQ EXIT0
 JSR RTNDO
 LDA #>ERROR1
 STA IND
 LDA #<ERROR1
 STA IND+1
 LDY #$00
EXIT1 LDA (IND),Y
 BEQ EXIT4
 CMP ERRMLI
 BEQ EXIT2
 INC IND
 BNE EXIT1
 INC IND+1
 BNE EXIT1
EXIT2 INY 
 LDA (IND),Y
 BNE EXIT2
 INY
EXIT3 LDA (IND),Y
 BEQ EXIT0
 JSR OUTDO
 INY
 BNE EXIT3
EXIT4 INC IND
 BNE EXIT5
 INC IND+1
EXIT5 LDA (IND),Y
 BNE EXIT4
 INC IND
 BNE EXIT6
 INC IND+1
EXIT6 LDA (IND),Y
 BNE EXIT1
EXIT7 LDA MLIERR,Y
 BEQ EXIT8
 JSR OUTDO
 INY
 BNE EXIT7
EXIT8 LDA ERRMLI
 JSR HEXOUT
EXIT0 LDA INDSAV
 STA IND
 LDA INDSAV+1
 STA IND+1
 LDA ASAV
 LDX XSAV
 LDY YSAV
;
; Hier FID-Exit
; =============
;
 RTS
;
INDSAV DB $00
 DB $00
ASAV DB $00
XSAV DB $00
YSAV DB $00
ERROR1 DB $2728
 DB $00
 ASC 'I/O-FEHLER'
 DB $00
 DB $2B
 DB $4E
 DB $00
 ASC 'SCHREIBGESCHUETZT'
 DB $00
 DB $40
 DB $00
 ASC 'ILLEGALER NAME'
 DB $00
 DB $44
 DB $45
 DB $46
 DB $00
 ASC 'NICHT GEFUNDEN'
 DB $00
 DB $47
 DB $57
 DB $00
 ASC 'DOPPELTER NAME'
 DB $00
 DB $48
 DB $49
 DB $00
 ASC 'DISK ODER DIRECTORY VOLL'
 DB $00
 DB $4A
 DB $00
 ASC 'FALSCHER DATEITYP'
 DB $00
 DB $00
MLIERR ASC 'MLI-'
 DB $00
;
; MLI-Befehle
;
RB JSR MLI
 DB $65
 DW RBCNT
 RTS
RBCNT DB $04
;
CR JSR MLI
 DB $C0
 DW CRCNT
 RTS
CRCNT DB $07
CRNAM DW NOM1
CRACC DB $C3
CRTYP DB $00
CRAUX DB $00
 DB $00
CRSTR DB $00
CRCDAT DB $00
 DB $00
CRCUHR DB $00
 DB $00
;
DE JSR MLI
 DB $C1
 DW DECNT
 RTS
DECNT DB $01
DENAM DW NOM1
;
RN JSR MLI
 DB $C2
 DW RNCNT
 RTS
RNCNT DB $02
RNNAM1 DW NOM1
RNNAM2 DW NOM2
;
SF JSR MLI
 DB $C3
 DW SFCNT
 RTS 
SFCNT DB $07
SFNAM DW NOM1
SFACC DB $00
SFTYP DB $00
SFAUX DB $00
 DB $00
SFNUL1 DB $00
SFNUL2 DB $00
 DB $00
SFMDAT DB $00
 DB $00
SFMUHR DB $00
 DB $00
;
GF JSR MLI
 DB $C4
 DW GFCNT
 RTS 
GFCNT DB $0A
GFNAM DW NOM1
GFACC DB $00
GFTYP DB $00
GFAUX DB $00
 DB $00
GFSTR DB $00
GFBLKS DB $00
 DB $00
GFMDAT DB $00
 DB $00
GFMUHR DB $00
 DB $00
GFCDAT DB $00
 DB $00
GFCUHR DB $00
 DB $00
;
OL JSR MLI
 DB $C5
 DW ONCNT
 RTS
ONCNT DB $02
ONUNIT DB $00
ONDPUF DW DPUF
;
SP JSR MLI
 DB $C6
 DW SPCNT
 RTS
SPCNT DB $01
SPNOM0 DW NOM0
;
GP JSR MLI
 DB $C7
 DW GPCNT
 RTS
GPCNT DB $01
GPNOM0 DW NOM0
;
OP JSR MLI
 DB $C8
 DW OPCNT
 RTS
OPCNT DB $03
OPNAM DW NOM1
OPBPUF DW BPUF
OPREF DB $00
;
NL JSR MLI
 DB $C9
 DW NLCNT
 RTS
NLCNT DB $03
NLREF DB $00
NLENAB DB $00
NLCHR DB $00
;
RD JSR MLI
 DB $CA
 DW RDCNT
 RTS
RDCNT DB $04
RDREF DB $00
RDDPUF DB $00
 DB $00
RDREQ DB $00
 DB $00
RDTRA DB $00
 DB $00
;
WR JSR MLI
 DB $CB
 DW WRCNT
 RTS
WRCNT DB $04
WRREF DB $00
WRDPUF DB $00
 DB $00
WRREQ DB $00
 DB $00
WRTRA DB $00
 DB $00
;
CL JSR MLI
 DB $CC
 DW CLCNT
 RTS
CLCNT DB $01
CLREF DB $00
;
GE JSR MLI
 DB $D1
 DW GECNT
 RTS
GECNT DB $02
GEREF DB $00
GEEOF DB $00
 DB $00
 DB $00
;
; Cout- und Prbyte-Ausgabe
;
OUTDO ORA #$80
 BNE OUTCHR
RTNDO LDA #$8D
 BNE OUTCHR
OUTSPC LDA #$A0
OUTCHR JMP COUT
;
; Hex-Word als Dezimalzahl ausgeben
; A, X und Y-Register werden veraendert
;
HEXAX STY HEXAZ 
 STA HEXHH
 STX HEXLL
 LDY #$80
 STY HEDE11
 LDX #0
 LDY #4
HEDE2 LDA #$30 ;'0'
 STA HEDE12
HEDE3 LDA HEXLL
 CMP HEDE8,Y
 LDA HEXHH
 SBC HEDE9,Y
 BCC HEDE4
 STA HEXHH
 LDA HEXLL
 SBC HEDE8,Y
 STA HEXLL
 INC HEDE12
 BNE HEDE3
HEDE4 LDA HEDE12
 INY
 DEY
 BEQ HEDE6
 CMP #$30 ;'0'
 BEQ HEDE5
 STA HEDE11
HEDE5 BIT HEDE11
 BPL HEDE6
 LDA #$30 ;'0', auch Space moeglich
HEDE6 STA HEDE10,X
 INX
 DEY
 BPL HEDE2
 LDY HEXAZ         ;Y=0 fuer mehr als 9999 Blocks
HEDE7 LDA HEDE10,Y ;Y=1 fuer bis zu   9999 Blocks
 JSR OUTDO
 INY
 CPY #5
 BNE HEDE7
 RTS
HEDE8 DB $01 ;<1
 DB $0A ;<10
 DB $64 ;<100
 DB $E8 ;<1000
 DB $10 ;<10000
HEDE9 DB $00 ;>1
 DB $00 ;>10
 DB $00 ;>100
 DB $03 ;>1000
 DB $27 ;>10000
HEDE10 DS 5
HEDE11 DS 1
HEDE12 DS 1
HEXLL DS 1
HEXHH DS 1
HEXAZ DS 1
;
HEXOUT JMP PRBYTE
;
; Reboot
;
REBOOT JMP RB
;
; Online
;
ONLIN LDA #>DPUF
 STA IND
 LDA #<DPUF
 STA IND+1
 LDY #$00
 TYA
ONLIN1 STA (IND),Y
 INY 
 BNE ONLIN1
 JSR OL
 BCC ONLP0
 STA ERRMLI
ONLIN2 JMP EXIT
ONLIN3 LDX NOM0
 BEQ ONLIN2
 JSR RTNDO
 LDY #$00
ONLIN4 INY
 LDA NOM0,Y
 JSR OUTDO
 DEX
 BNE ONLIN4
 BEQ ONLIN2
ONLP0 LDY #$00
 LDA (IND),Y
 BNE ONLP1
 INY
 LDA (IND),Y
 BEQ ONLIN3
ONLP1 JSR RTNDO
 LDY #$00
 LDA #$D3
 JSR OUTDO
 LDA (IND),Y
 AND #$70
 LSR A
 LSR A
 LSR A
 LSR A
 ORA #$B0
 JSR OUTDO
 LDA #$AC
 JSR OUTDO
 LDA (IND),Y
 AND #$0F
 TAX 
 LDA #$C4
 JSR OUTDO
 LDA (IND),Y
 BPL ONLP2
 LDA #$B2
 BNE ONLP3
ONLP2 LDA #$B1
ONLP3 JSR OUTDO
 JSR OUTSPC
 CPX #$00
 BEQ ONLP5
 LDA #$AF
 JSR OUTDO
ONLP4 INY 
 LDA (IND),Y
 JSR OUTDO
 DEX
 BNE ONLP4
 BEQ ONLP6
ONLP5 LDA #$BF
 JSR OUTDO
ONLP6 CLC 
 LDA IND
 ADC #$10
 STA IND
 BCC ONLP0
 INC IND+1
 BNE ONLP0
;
; Prefix
;
PREFX LDA NOM0
 BEQ GETFX
SETFIX JSR SP     ;Getfix und gleich darauf Setfix
 BCC GETFX        ;wegen Partial Prefix!
PREFX1 STA ERRMLI
PREFX2 LDA #$00
 STA NOM0
PREFX3 LDA NOM0
 CMP #$41
 BCS PREFX2
 JMP EXIT
;
GETFX JSR GP
 BCS PREFX1
 JSR RTNDO
 LDY #$00
 LDX NOM0
 BNE GETFX1
 LDA #$BF
 JSR OUTDO
 JMP PREFX3
GETFX1 INY
 LDA NOM0,Y
 JSR OUTDO
 DEX
 BNE GETFX1
 BEQ PREFX3
;
; Catalog
;
CAT LDX NOM1
 BNE CAT1
 LDX NOM0
 BNE CATMV1
 LDA #$81
 STA ERRALL
 BNE CAT4
CATMV1 STX NOM1
 LDY #$00
CATMV2 INY
 LDA NOM0,Y
 STA NOM1,Y
 DEX
 BNE CATMV2
CAT1 JSR GF
 LDA #$4A
 LDX GFTYP
 CPX #$0F
 BNE CAT2
 JSR OP
 BCC CAT5
CAT2 STA ERRMLI
CAT3 JSR CL
CAT4 JMP EXIT
CAT5 LDA OPREF
 STA NLREF
 JSR NL
 BCS CAT2
CAT6 LDA OPREF
 STA RDREF
 LDA #>DPUF
 STA RDDPUF
 LDA #<DPUF
 STA RDDPUF+1
 LDA #>$0200
 STA RDREQ
 LDA #<$0200
 STA RDREQ+1
 JSR RD
 BCS CAT2
 LDA #>DPUF+4
 STA IND
 LDA #<DPUF
 STA IND+1
CAT7 LDY #$00
 LDA (IND),Y
 BEQ CAT15
 AND #$F0
 CMP #$E0
 BCS CAT15
 JSR RTNDO
 LDY #$1E
 LDA (IND),Y
 LDX #$A0
 AND #$C2
 CMP #$C2
 BEQ CAT8
 LDX #$AA
CAT8 TXA
 JSR OUTDO
 LDY #$10
 LDA (IND),Y
 LDX #$04
CAT9 CMP CAT10,X
 BEQ CAT12
 DEX
 BPL CAT9
 LDA #$BF
 BNE CAT13
CAT10 DB $04
 DB $06
 DB $0F
 DB $FC
 DB $FF
CAT11 ASC 'TBDAS'
CAT12 LDA CAT11,X
CAT13 JSR OUTDO
 JSR OUTSPC
 LDY #$13
 LDA (IND),Y
 TAX 
 LDY #$14
 LDA (IND),Y
 LDY #0      ;5-stellig
 JSR HEXAX
 JSR OUTSPC
 LDY #$00
 LDA (IND),Y
 AND #$0F
 TAX
CAT14 INY
 LDA (IND),Y
 JSR OUTDO
 DEX
 BNE CAT14
CAT15 CLC
 LDA IND
 ADC #$27
 STA IND
 LDA IND+1
 ADC #$00
 STA IND+1
 LDA IND
 CMP #$FF
 BEQ CAT16
 JMP CAT7
CAT16 LDA #>DPUF+2
 STA IND
 LDA #<DPUF
 STA IND+1
 LDY #$00
 CLC
 LDA (IND),Y
 INY
 ADC (IND),Y
 BNE CAT19
;
 LDA GFSTR
 CMP #$0F
 BNE CAT18
 JSR RTNDO
 JSR OUTSPC
 JSR OUTSPC
 JSR OUTSPC
 SEC
 LDA GFAUX
 SBC GFBLKS
 TAX
 LDA GFAUX+1
 SBC GFBLKS+1
 LDY #0      ;5-stellig
 JSR HEXAX
 LDY #0
CAT17 LDA CAT20,Y
 BEQ CAT18
 ORA #$80
 JSR OUTDO
 INY
 BNE CAT17 
CAT18 JMP CAT3
CAT19 JMP CAT6
CAT20 ASC ' FREI'
 DB $00
;
; Create
;
CRTYP0 DB $0F
CRSTR0 DB $0D
CREAT LDA NOM0
 BEQ CREAT1
 LDA NOM1
 BEQ CREAT2
 BNE CREAT5
CREAT1 LDA #$81
 BNE CREAT3
CREAT2 LDA #$82
CREAT3 STA ERRALL
CREAT4 JMP EXIT
CREAT5 LDA CRTYP0
 STA CRTYP
 LDA #$00
 STA CRAUX
 LDA #$00
 STA CRAUX+1
 LDX #$03
CREAT6 LDA MLIDAT,X
 STA CRCDAT,X
 DEX
 BPL CREAT6
 LDA CRSTR0
 STA CRSTR
 JSR CR
 BCC CREAT4
 STA ERRMLI
 BCS CREAT4
;
; Delete
;
DELET LDA NOM1
 BNE DELET3
 LDA #$82
 STA ERRALL
DELET1 JMP EXIT
DELET2 STA ERRMLI
 BCS DELET1
DELET3 JSR DE
 BCC DELET1
 BCS DELET2
;
; Lock und Unlock
;
LKUNL LDA NOM1
 BNE LKUNL3
 LDA #$82
 STA ERRALL
 BNE LKUNL2
LKUNL1 STA ERRMLI
LKUNL2 JMP EXIT
LKUNL3 JSR GTST
 BCS LKUNL1
 LDA BEFEHL
 CMP #$07
 BEQ LKUNL5
 LDA SFACC
 AND #$21
LKUNL4 STA SFACC
 JSR SF
 BCS LKUNL1
 BCC LKUNL2
LKUNL5 LDA SFACC
 ORA #$C2
 BNE LKUNL4
GTST JSR GF
 BCS GTST2
 LDA GFACC
 STA SFACC
 LDA GFTYP
 STA SFTYP
 LDA GFAUX
 STA SFAUX
 LDA GFAUX+1
 STA SFAUX+1
 LDX #$03
GTST1 LDA GFMDAT,X
 STA SFMDAT,X
 DEX
 BPL GTST1
GTST2 RTS
;
; Rename
;
RENOM LDA NOM1
 BNE RENOM3
 LDA #$82
RENOM1 STA ERRALL
RENOM2 JMP EXIT
RENOM3 LDA NOM2
 BNE RENOM4
 LDA #$83
 BNE RENOM1
RENOM4 JSR RN
 BCC RENOM2
 STA ERRMLI
 BCS RENOM2
;
; Bsave
;
BSVTYP DB $06  ;Bin-Datei
BSAV LDA NOM1
 BNE BSAV4
 LDA #$82
BSAV1 STA ERRALL
BSAV2 JMP EXIT
BSAV3 STA ERRMLI
 JMP BSAV2
BSAV4 CLC
 LDA BLEN
 ADC BLEN+1
 BNE BSAV5
 LDA #$84
 BNE BSAV1
BSAV5 JSR GF
 BCS BSAV7
 LDA GFTYP
 CMP BSVTYP
 BEQ BSAV6
 LDA #$4A
 BNE BSAV3
BSAV6 JSR DE
 BCS BSAV3
BSAV7 LDA BSVTYP
 STA CRTYP
 LDA #$00
 STA CRAUX
 LDA #$00
 STA CRAUX+1
 LDA #$01
 STA CRSTR
 LDX #$03
BSAV8 LDA MLIDAT,X
 STA CRCDAT,X
 DEX
 BPL BSAV8
 JSR CR
 BCS BSAV3
 JSR OP
 BCS BSAV9
 LDA OPREF
 STA NLREF
 STA WRREF
 JSR NL
 BCS BSAV9
 LDA BANF
 STA WRDPUF
 LDA BANF+1
 STA WRDPUF+1
 LDA BLEN
 STA WRREQ
 LDA BLEN+1
 STA WRREQ+1
 JSR WR
 BCC BSAV10
BSAV9 STA ERRMLI
BSAV10 JSR CL
 JMP BSAV2
;
; Bload
;
BLDTYP DB $06  ;Bin-Datei
BLOD LDA NOM1
 BNE BLOD4
 LDA #$82
BLOD1 STA ERRALL
BLOD2 JMP EXIT
BLOD3 STA ERRMLI
 JMP BLOD2
BLOD4 CLC
 LDA BLEN
 ADC BLEN+1
 BNE BLOD5
 LDA #$84
 BNE BLOD1
BLOD5 JSR GF
 BCS BLOD3
 LDA GFTYP
 CMP BLDTYP
 BEQ BLOD6
 LDA #$4A
 BNE BLOD3
BLOD6 LDA #$00
 STA RDTRA
 STA RDTRA+1
 JSR OP
 BCS BLOD10
 LDA OPREF
 STA NLREF
 STA GEREF
 STA RDREF
 JSR NL
 BCS BLOD10
 JSR GE
 BCS BLOD10
 LDA GEEOF+2
 BEQ BLOD7
 LDA #$85
 STA ERRALL
 BNE BLOD11
BLOD7 LDA GEEOF
 STA RDREQ
 LDA GEEOF+1
 STA RDREQ+1
 SEC 
 LDA BLEN
 SBC GEEOF
 LDA BLEN+1
 SBC GEEOF+1
 BCS BLOD9
BLOD8 LDA BLEN
 STA RDREQ
 LDA BLEN+1
 STA RDREQ+1
 LDA #$85
 STA ERRALL
BLOD9 LDA BANF
 STA RDDPUF
 LDA BANF+1
 STA RDDPUF+1
 JSR RD
 BCC BLOD11
BLOD10 STA ERRMLI
BLOD11 JSR CL
 LDA RDTRA
 STA FLEN
 LDA RDTRA+1
 STA FLEN+1
 JMP BLOD2
;
;-----------------------------
;
; Name-Kopier-Unterroutine
;
NOMMV1 LDY #0
NOMMV2 LDA (_T),Y
 CMP #$20
 BEQ NOMMV3
 INY
 STA (_T+2),Y
 CPY #64
 BNE NOMMV2
NOMMV3 TYA
 LDY #0
 STA (_T+2),Y
 RTS
;
; Parameter-Vektoren: (INDIRECT), Y
;
ERRAZ DS 2  ;nachher
ERRMZ DS 2  ;nachher
BEFEZ DS 2
FLENZ DS 2  ;nachher
BLENZ DS 2
BANFZ DS 2
NOM2Z DS 2
NOM1Z DS 2
NOM0Z DS 2  ;nachher
;
; Parameter-Parse-ANFANG
; ======================
;
ANFANG STX _T+10  ;X-Register retten
;
 LDY #5  ;Zeiger in Tabelle kopieren
 LDX #0
PTR LDA (_SP),Y
 STA ERRAZ,X
 INY
 INX
 CPX #18
 BNE PTR
;
 LDA NOM0Z   ;Prefix kopieren
 STA _T
 LDA NOM0Z+1
 STA _T+1
 LDA #>NOM0
 STA _T+2
 LDA #<NOM0
 STA _T+3
 JSR NOMMV1
;
 LDA NOM1Z  ;Name1 kopieren
 STA _T
 LDA NOM1Z+1
 STA _T+1
 LDA #>NOM1
 STA _T+2
 LDA #<NOM1
 STA _T+3
 JSR NOMMV1
;
 LDA NOM2Z   ;Name2 kopieren
 STA _T
 LDA NOM2Z+1
 STA _T+1
 LDA #>NOM2
 STA _T+2
 LDA #<NOM2
 STA _T+3
 JSR NOMMV1
;
; Integer BANF und BLEN kopieren
;
 LDA BANFZ
 STA _T
 LDA BANFZ+1
 STA _T+1
 LDY #0
 LDA (_T),Y
 STA BANF
 INY
 LDA (_T),Y
 STA BANF+1
;
 LDA BLENZ
 STA _T
 LDA BLENZ+1
 STA _T+1
 LDY #0
 LDA (_T),Y
 STA BLEN
 INY
 LDA (_T),Y
 STA BLEN+1
;
; BEFEHL
;
 LDA BEFEZ
 STA _T
 LDA BEFEZ+1
 STA _T+1
 LDY #0
 LDA (_T),Y
 STA BEFEHL
;
; Aufruf von FID
; ==============
;
 JSR ENTRY
;
; Ausgabeparameter kopieren
;
 LDA FLENZ   ;File-Laenge
 STA _T
 LDA FLENZ+1
 STA _T+1
 LDY #0
 LDA FLEN
 STA (_T),Y
 INY
 LDA FLEN+1
 STA (_T),Y
;
 LDA ERRMZ   ;Error-MLI
 STA _T
 LDA ERRMZ+1
 STA _T+1
 LDY #0
 LDA ERRMLI
 STA (_T),Y
;
 LDA ERRAZ   ;Error-Allgemein
 STA _T
 LDA ERRAZ+1
 STA _T+1
 LDY #0
 LDA ERRALL
 STA (_T),Y
;
 LDA NOM0Z  ;Prefix kopieren
 STA _T
 LDA NOM0Z+1
 STA _T+1
 LDY #0
 LDA #$20   ;erst durch Space loeschen
 STA (_T),Y
 LDX NOM0
 BEQ ENDE ;leer
NOM0K1 LDA ASCII0,Y  ;Ascii von Prefix
 AND #$7F
 STA (_T),Y
 INY
 DEX
 BNE NOM0K1
 LDA #$20          ;Rest mit Spaces fuellen
NOM0K2 CPY #64
 BCS ENDE
 STA (_T),Y
 INY
 BNE NOM0K2
; 
; Parameter-Parse-ENDE
; ====================
;
ENDE LDX _T+10  ;X-Register laden
#
END;

{----------------------------------}

PROCEDURE COPY
 (VAR KSTR: KOPYNAME; VAR KERR: INTEGER);

BEGIN
#A
 JMP KOPY1
;
; Spezial-FID-Copy
; fuer Kyan-PRODOS.LIB
; Vgl. "ProDOS fuer Aufsteiger, Bd. 2", S. 127ff.
;
; Copy-Befehl-Puffer           = PUFFER = $0200-$02FF
; I/O-Block-Read-Puffer        = BPUFRD = $0400 Bytes
; I/O-Block-Write-Puffer       = BPUFWR = $0400 Bytes
; Gemeinsamer R/W-Pufferanfang = BUFBEG = $2000
; Pufferlaenge in Pages        = LENMM = $20 = 32 = $2000
; Die Hires-Seite 1 wird also als R/W-Puffer benutzt (USESHIRES!)
;
; Copy-Befehl-Puffer-Aufbau:
;
; $XX00: K / V 1 / N 1 , / V 2 / N 2
;        0 1 2 3 4 5 6 7 8 9 A B C D
;        1+64          1+64          = 130 Zeichen maximal
;
; Es wird jedoch nur ein Array von 64 Zeichen definiert,
; damit die Befehlszeile gut in eine Bildschirmzeile passt.
; KSTR := 'K/3456789-123456789-123456789-123456789-123456789-123456789-1234'
; Bei Monster-Volume/Dir-Namen auf 130 erhoehen und unten aendern!!!!!!
; Die folgenden Labels sind am Anfang von FID definiert.
; Bei Stand-alone-Copy-Routine hier definieren.
;
;PRBYTE EQU $FDDA
;COUT   EQU $FDED
;MLI    EQU $BF00
;BPUFRD EQU $2000  ;4 Pages
;BPUFWR EQU $2400  ;4 Pages
;PUFBEG EQU $2800  ;LENMM dann $18 = 24 ($2800-$4000)
;PUFFER EQU $0200  ;Input-Puffer nehmen
;
CYERR  DS 1
CYERRP DS 2
CYSTRP DS 2
;
KOPY1 STX _T+10  ;X-Register retten
;
; Zeiger kopieren
;
 LDY #5
 LDX #0
KOPY2 LDA (_SP),Y
 STA CYERRP,X
 INY
 INX
 CPX #4
 BNE KOPY2
;
; Copystring kopieren
;
 LDA CYSTRP
 STA _T
 LDA CYSTRP+1
 STA _T+1
;
 LDY #0         ;zunaechst Name loeschen
 LDA #$0D
 STA PUFFER,Y
KOPY3 LDA (_T),Y
 AND #$7F
 CMP #$20    ;Space
 BEQ KOPY4
 STA PUFFER,Y
 INY
 CPY #64         ;Laenge 64, hier ggf. auf 130 erhoehen!!!!
 BNE KOPY3
KOPY4 LDA #$0D   ;64. Zeichen = 0D als Endmarker (0-63 + 1)
 STA PUFFER,Y
;
; Copyerror auf 0 und Copybefehl aufrufen
;
 LDA #0
 STA CYERR
 JSR KOPYA
;
; Copyerror kopieren
;
 LDA CYERRP
 STA _T
 LDA CYERRP+1
 STA _T+1
 LDY #0
 LDA CYERR
 STA (_T),Y
;
; MLI-Fehler ausgeben
;
 BEQ KOPY5
 CMP #$5A
 BCS KOPY5  ;MLI-Fehler $01-$5A
 LDA #$8D
 JSR COUT
 LDA #$CD ;M
 JSR COUT
 LDA #$CC ;L
 JSR COUT
 LDA #$C9 ;I
 JSR COUT
 LDA #$AD ;-
 JSR COUT
 LDA CYERR
 JSR PRBYTE
;
KOPY5 JMP KOPYX   ;Exit
;
; Eigentliche Kopierroutine
;
KOPYA LDA #$20 ;$2000 Puffer-Laenge
 STA LENMM
 LDY #$00
 STY KONST  ;Stelle von "K" von "K/Volume1..."
 BEQ COPY1
ERROR STA CYERR
KOPYE RTS           ;Ende
ERR90 LDA #$90
 BNE ERROR
;
; Copystring auf Legalitaet pruefen
;
COPY1 JSR BITAB
 LDY KONST
 STY FI1
 INY
 LDA PUFFER,Y
 CMP #$2F ;/
 BNE ERR90
 LDX #$00
 STX DASHFL
 BEQ COPY3
COPY2 LDA PUFFER,Y
 CMP #$2C ;,
 BEQ COPY4
 JSR KOVERT
 BCS ERR90
COPY3 INX
 INY
 BNE COPY2
 BEQ ERR90
COPY4 LDA DASHFL
 BEQ ERR90
 STX FI1+1
 CPX #64
 BCS ERR90
 CPX #$04
 BCC ERR90
 STY FI2
 STY DIR2
 INY
 LDA PUFFER,Y
 CMP #$2F ;/
 BNE ERR90
 LDX #$00
 STX DASHFL
 BEQ COPY6
COPY5 LDA PUFFER,Y
 CMP #$0D
 BEQ COPY7
 JSR KOVERT
 BCS ERR90
COPY6 INX
 INY
 BNE COPY5
 BEQ ERR90
COPY7 LDA DASHFL
 BEQ ERR90
 CPX #64
 BCS ERR90
 CPX #$04
 BCC ERR90
 STX FI2+1
 LDY DIR2
 INY
 LDX #$00
COPY8 INY
 INX
 LDA PUFFER,Y
 CMP #$2F ;/
 BNE COPY8
 STX DIR2+1
 LDX FI1
COPY9 INX
 LDA PUFFER,X
 CMP #$2F ;/
 BEQ COPY10
 CMP #$0D
 BEQ MLI01
 BNE COPY9
COPY10 INX
 LDA PUFFER,X
 CMP #$0D
 BEQ MLI01
 CMP #$41 ;A
 BCS COPY9
 JMP ERR90
;
; Unter Kyan 2.0 sind $0800-$BEFF
; in der ProDOS-Bitmap ($BF59-$BF5F)
; als frei markiert.
;
MLI01 LDA BITMAP
 BEQ MLI03
 LDY #$59
MLI02 LDA MLI,Y
 BNE ERR91
 INY
 CPY #$6F
 BNE MLI02
 LDA MLI,Y
 CMP #$01
 BEQ MLI03
ERR91 LDA #$91
 BNE FEHLM1
ERR92 LDA #$92
FEHLM1 JMP ERROR
MLI03 LDX FI1
 STX NAME0
 LDA FI1+1
 STA PUFFER,X
 JSR GINF0
 BCS FEHLM1
 LDA SPEI0
 CMP #$0D
 BCS ERR92
 LDX #14
MLI04 LDA AKK0,X
 STA AKKA,X
 DEX
 BPL MLI04
 LDX FI1
 STX NAME4
 LDA #<BPUFRD ;High
 STA IOBUF4+1
 JSR OPEN4
 BCS FEHLM2
 LDA FIREF4
 STA FI1REF
 STA FIREF5
 JSR NEULI5
 BCS FEHLM2
 LDA FI1REF
 STA FIREF9
 JSR GETEO9
 BCC MLI05
FEHLM2 PHA
 JSR CLOSE8
 PLA
 JMP ERROR
ERR93 LDA #$93
 BNE FEHLM2
MLI05 LDX #$00
 LDY #$02
 SEC
MLI06 LDA EOF9,X
 STA LAENGE,X
 BEQ MLI07
 CLC
MLI07 INX
 DEY
 BPL MLI06
 BCS ERR93
 LDA #$00
 STA SCHUB
MLI08 LDX #$00
 LDY #$02
 SEC
MLI08A LDA LAENGE,X
 SBC LENLL,X
 STA REST,X
 INX
 DEY
 BPL MLI08A
 BCC MLI09
 LDA REST
 ORA REST+1
 ORA REST+2
 BEQ MLI09
 LDY #$02
MLI08B LDA REST,Y
 STA LAENGE,Y
 DEY
 BPL MLI08B
 INC SCHUB
 BNE MLI08
ERR94 LDA #$94
 BNE FEHLM2
MLI09 LDA LAENGE
 STA REST
 LDA LAENGE+1
 STA REST+1
 JSR RDHUN1
 BCC MLI10
FEHLM3 JMP FEHLM2
MLI10 LDX DIR2
 STX NAME0
 LDA DIR2+1
 STA PUFFER,X
 JSR GINF0
 BCS FEHLM3
 LDX FI2
 STX NAME0
 LDA FI2+1
 STA PUFFER,X
 JSR GINF0
 BCS MLI11
 LDX FI2
 STX NAME2
 JSR ERASE2
 BCS FEHLM3
MLI11 LDX FI2
 STX NAME3
 LDA FITYPA
 STA FITYP3
 LDA HILFTA
 STA HILFT3
 LDA HILFTA+1
 STA HILFT3+1
 LDX #$03
MLI12 LDA CDATEA,X
 STA CDATE3,X
 DEX
 BPL MLI12
 JSR KREA3
 BCC MLI13
FEHLM4 PHA
 JSR CLOSE8
 LDX FI2
 STX NAME2
 JSR ERASE2
 PLA
 JMP ERROR
MLI13 LDX FI2
 STX NAME4
 LDA #<BPUFWR ;High
 STA IOBUF4+1
 JSR OPEN4
 BCS FEHLM4
 LDA FIREF4
 STA FI2REF
 STA FIREF5
 JSR NEULI5
 BCS FEHLM4
 BCC MLI15
MLI14 JSR RDHUN1
 BCS FEHLM4
MLI15 JSR WRHUN1
 BCS FEHLM4
 DEC SCHUB
 BPL MLI14
 JSR CLOSE8
 LDX #10
MLI16 LDA AKKA,X
 STA AKK1,X
 DEX
 BPL MLI16
 LDX FI2
 STX NAME1
 JSR SINF1
 BCS FEHLM4
 JMP KOPYE          ;Ende
;
; Schubweise lesen/schreiben
;
RDHUN1 LDA FI1REF
 STA FIREF6
 LDA LENLL
 STA VERLA6
 LDA LENLL+1
 STA VERLA6+1
 LDA SCHUB
 BNE RDHUN2
 LDA REST
 STA VERLA6
 LDA REST+1
 STA VERLA6+1
RDHUN2 JMP READ6
WRHUN1 LDA FI2REF
 STA FIREF7
 LDA LENLL
 STA VERLA7
 LDA LENLL+1
 STA VERLA7+1
 LDA SCHUB
 BNE WRHUN2
 LDA REST
 STA VERLA7
 LDA REST+1
 STA VERLA7+1
WRHUN2 JMP WRITE7
;
; Namenskonvertierung
;
KOVERT CMP #$2E ;.
 BEQ KOOKAY
 CMP #$2F ;/
 BEQ DASH
 BCC KOERR
 CMP #$3A ;:
 BCC KOOKAY
 CMP #$41 ;A
 BCC KOERR
 CMP #$5B ;[
 BCC KOOKAY
 CMP #$61 ;a
 BCC KOERR
 CMP #$7B ;{
 BCS KOERR
 SEC
 SBC #$20
 STA PUFFER,Y
KOOKAY CLC
 RTS
KOERR SEC
 RTS
DASH INC DASHFL
 BNE KOOKAY
;
BITAB LDY KONST
BITAB1 INY
 LDA PUFFER,Y
 AND #$7F
 STA PUFFER,Y
 CMP #$0D
 BNE BITAB1
 RTS
;
; MLI-Befehle
;
GINF0 JSR MLI
 DB $C4
 DW COUNT0
 RTS
COUNT0 DB $0A
NAME0 DW PUFFER
AKK0 DB $00
FITYP0 DB $00
HILFT0 DB $00
 DB $00
SPEI0 DB $00
BLOEK0 DB $00
 DB $00
MDATE0 DB $00
 DB $00
MTIME0 DB $00
 DB $00
CDATE0 DB $00
 DB $00
CTIME0 DB $00
 DB $00
;
SINF1 JSR MLI
 DB $C3
 DW COUNT1
 RTS
COUNT1 DB $07
NAME1 DW PUFFER
AKK1 DB $00
FITYP1 DB $00
HILFT1 DB $00
 DB $00
SPEI1 DB $00
BLOEK1 DB $00
 DB $00
MDATE1 DB $00
 DB $00
MTIME1 DB $00
 DB $00
;
ERASE2 JSR MLI
 DB $C1
 DW COUNT2
 RTS
COUNT2 DB $01
NAME2 DW PUFFER
;
KREA3 JSR MLI
 DB $C0
 DW COUNT3
 RTS
COUNT3 DB $07
NAME3 DW PUFFER
AKK3 DB $C3
FITYP3 DB $00
HILFT3 DB $00
 DB $00
SPEI3 DB $01
CDATE3 DB $00
 DB $00
CTIME3 DB $00
 DB $00
;
OPEN4 JSR MLI
 DB $C8
 DW COUNT4
 RTS
COUNT4 DB $03
NAME4 DW PUFFER
IOBUF4 DB $00
 DB $00
FIREF4 DB $00
;
NEULI5 JSR MLI
 DB $C9
 DW COUNT5
 RTS
COUNT5 DB $03
FIREF5 DB $00
 DB $00
NEUCH DB $00
;
READ6 JSR MLI
 DB $CA
 DW COUNT6
 RTS
COUNT6 DB $04
FIREF6 DB $00
DATAB6 DW PUFBEG
VERLA6 DB $00
 DB $00
TRANS6 DB $00
 DB $00
;
WRITE7 JSR MLI
 DB $CB
 DW COUNT7
 RTS
COUNT7 DB $04
FIREF7 DB $00
DATAB7 DW PUFBEG
VERLA7 DB $00
 DB $00
TRANS7 DB $00
 DB $00
;
CLOSE8 JSR MLI
 DB $CC
 DW COUNT8
 RTS
COUNT8 DB $01
FIREF8 DB $00
;
GETEO9 JSR MLI
 DB $D1
 DW COUNT9
 RTS
COUNT9 DB $02
FIREF9 DB $00
EOF9 DB $00
 DB $00
 DB $00
;
; Temporaere MLI-Variablen
;
AKKA DB $00
FITYPA DB $00
HILFTA DB $00
 DB $00
SPEIA DB $00
BLOEKA DB $00
 DB $00
MDATEA DB $00
 DB $00
MTIMEA DB $00
 DB $00
CDATEA DB $00
 DB $00
CTIMEA DB $00
 DB $00
FI1REF DB $00
FI2REF DB $00
;
; Pufferlaenge
;
LENLL DB $00
LENMM DB $20 ;$2000
LENHH DB $00
BITMAP DB $01
FI1 DB $03
 DB $0B
FI2 DB $0F
 DB $0B
DIR2 DB $0F
 DB $05
KONST DB $03
;
; Kopierschuebe
;
SCHUB DB $00
LAENGE DB $00
 DB $00
 DB $00
REST DB $00
 DB $00
 DB $00
;
DASHFL DB $00
;
KOPYX LDX _T+10  ; X-Register laden
#
END;

{-------------------------------------------------------}
FUNCTION RDKEY: CHAR;
BEGIN
RDKEY := '1'; {Dummy}
#A
    STX _T       ;X-Register speichern
    JSR $FD0C   ;RDKEY: Tastaturabfrage
    AND #$5F    ;Bit 7 loeschen und klein in gross
    LDY #5
    STA (_SP),Y  ;in LL von C poken
    LDX _T       ;X-Register laden
#
END;

{-------------------------------------------------------}

BEGIN
WRITELN (CHR(12)); {Home}
WRITELN ('PRODOS-FID FUER KYAN 2.0');
WRITELN ('VON U.STIEHL * 10.5.1986');

{Die Parameter muessen initialisiert werden,
 sonst dreht das Assemblerprogramm durch,
 indem es "zufaellige" Zeiger ermittelt}

NAME0[1]   :=  ' ';   NAME1[1] :=  ' ';   NAME2[1] := ' ';
BANF       := 8192;   BLEN     := 8192;   FLEN     :=   0;
ERRMLI     :=    0;   ERRALL   :=    0;   BEFEHL   :=   0;
KSTR[1]    :=  ' ';   KERR     :=    0;
AUSWAHL := 'QOPCMDLURSBK'; {siehe unten Menue}

{Prefix vorhanden?}
BEFEHL := 2; FID (NAME0,  NAME1,  NAME2,
                  BANF,   BLEN,   FLEN, 
                  BEFEHL, ERRMLI, ERRALL); 

REPEAT
 WRITELN;
 IF NAME0[1] = ' ' THEN WRITELN (CHR(7), 'PREFIX SETZEN!');
 REPEAT
  {0}  WRITE ('Q QUIT  '  ); {ohne Parameter} 
  {1}  WRITE ('O ONLINE  '); {ohne Parameter}
  {2}  WRITE ('P PREFIX  '); {NAME0 oder Return}
  {3}  WRITE ('C CATALOG '); {NAME1 oder Return}
  {4}  WRITE ('M MAKEDIR '); {NAME1}
  {5}  WRITE ('D DELETE  '); {NAME1} WRITELN;
  {6}  WRITE ('L LOCK  '  ); {NAME1}
  {7}  WRITE ('U UNLOCK  '); {NAME1}
  {8}  WRITE ('R RENAME  '); {NAME1 und NAME2}
  {9}  WRITE ('S SAVE    '); {NAME1 und BANF und BLEN}
 {10}  WRITE ('B BLOAD   '); {NAME1 und BANF und BLEN}
 {11}  WRITE ('K KOPY    '); {KSTR}
       WRITELN;
 WRITE ('BEFEHL: '); TASTE := RDKEY; WRITELN;
 UNTIL TASTE IN ['Q','O','P','C','M','D','L','U','R','S','B','K'];
 FOR I := 1 TO 12 DO IF AUSWAHL[I] = TASTE THEN BEFEHL := I-1;
 
 IF BEFEHL = 2 THEN BEGIN WRITE ('PREFIX: '); READLN (NAME0) END;
 IF BEFEHL = 8 THEN BEGIN WRITE ('ALTNAME: '); READLN (NAME1);
                          WRITE ('NEUNAME: '); READLN (NAME2) END;
 IF BEFEHL IN [3,4,5,6,7,9,10] THEN
  BEGIN WRITE ('NAME: '); READLN (NAME1) END;
 
 IF BEFEHL = 11 THEN
  BEGIN
   WRITELN ('K/DIR1/DATEI,/DIR2/DATEI');
   READLN (KSTR);
   COPY (KSTR, KERR); {COPY-Aufruf}
   IF (KERR > 0) THEN WRITELN;
   IF (KERR = 144) THEN WRITE ('SYNTAX-FEHLER!');
   IF (KERR = 145) THEN WRITE ('SBM-KONFLIKT');
   IF (KERR = 146) THEN WRITE ('DIRECTORY!');
   IF (KERR = 147) THEN WRITE ('LEERDATEI!');
   IF (KERR = 148) THEN WRITE ('GROESSER ALS 2M!')
  END
 ELSE
  BEGIN
   FID (NAME0, NAME1, NAME2, BANF, BLEN, FLEN,
    BEFEHL, ERRMLI, ERRALL); {PRODOS-Aufruf}
   IF (ERRALL > 0) THEN WRITELN;
   IF (ERRALL = 128) THEN WRITE ('ILLEGALER BEFEHL!');
   IF (ERRALL = 129) THEN WRITE ('PREFIX FEHLT!');
   IF (ERRALL = 130) THEN WRITE ('DATEINAME FEHLT!');
   IF (ERRALL = 131) THEN WRITE ('NEUNAME FEHLT');
   IF (ERRALL = 132) THEN WRITE ('BLOADLAENGE NULL!');
   IF (ERRALL = 133) THEN WRITE ('TEIL-BLOAD!')
  END
UNTIL BEFEHL = 0
END.
