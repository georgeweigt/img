
PROGRAM KYANFID2;

{FID2: nur die Befehle Catalog, Rename usw.,}
{also ohne Bsave und Bload und ohne Copy.}
{Die UsesHires-Option ist deshalb hier entbehrlich}
{im Gegensatz zu FID und FID1}

TYPE  FILENAME = ARRAY [1..64] OF CHAR; {fest!}

VAR   NAME0,   NAME1,    NAME2:   FILENAME;
      BEFEHL,  ERRMLI,   ERRALL:  INTEGER;

      AUSWAHL: ARRAY [1..12] OF CHAR;
      TASTE: CHAR; I: INTEGER;
{---------------------------------------}

PROCEDURE FID
 (VAR NAME0,  NAME1,  NAME2:  FILENAME;
  VAR BEFEHL, ERRMLI, ERRALL: INTEGER);

BEGIN
#A
IND EQU _T
MLI EQU $BF00
MLIDAT EQU $BF90
MLIUHR EQU $BF92
PRBYTE EQU $FDDA
;
; Sprung zum Parameter-Parse-ANFANG
; =================================
;
 JMP ANFANG
;
ORIG EQU *
ORIGL EQU >ORIG
FUELL DS 256-ORIGL
BPUF DS $0400
DPUF DS $0200
;
NOM0 DB $00
ASCII0 DS 66
NOM1 DB $00
ASCII1 DS 64
NOM2 DB $00
ASCII2 DS 64
BANF DB $00
 DB $00
BLEN DB $00
 DB $00
FLEN DB $00
 DB $00
BEFEHL DB $00
ERRMLI DB $00
ERRALL DB $00
;
; Hier PRODOS-Entry
; =================
;
ENTRY STA ASAV
 STX XSAV
 STY YSAV
;
; Block-Puffer wirklich auf Seitengrenze?
;
 LDA #>BPUF  ;Low-Byte
 CMP #0
 BEQ OKAY
 JMP $FF59 ;Abbruch durch Monitorsprung
;
OKAY LDA IND
 STA INDSAV
 LDA IND+1
 STA INDSAV+1
 LDA #$00
 STA ERRMLI
 STA ERRALL
 LDA BEFEHL
 CMP #$0B
 BCC ENTRY1
 LDA #$80
 STA ERRALL
 JMP EXIT
ENTRY1 ASL A 
 TAX
 LDA JMPTAB,X
 STA ENTRY2+1
 INX
 LDA JMPTAB,X
 STA ENTRY2+2
ENTRY2 JMP $FFFF
JMPTAB DW REBOOT
 DW ONLIN
 DW PREFX
 DW CAT
 DW CREAT
 DW DELET
 DW LKUNL
 DW LKUNL
 DW RENOM
 DW BSAV
 DW BLOD
EXIT LDA ERRMLI
 BEQ EXIT0
 JSR RTNDO
 LDA #>ERROR1
 STA IND
 LDA #<ERROR1
 STA IND+1
 LDY #$00
EXIT1 LDA (IND),Y
 BEQ EXIT4
 CMP ERRMLI
 BEQ EXIT2
 INC IND
 BNE EXIT1
 INC IND+1
 BNE EXIT1
EXIT2 INY 
 LDA (IND),Y
 BNE EXIT2
 INY
EXIT3 LDA (IND),Y
 BEQ EXIT0
 JSR OUTDO
 INY
 BNE EXIT3
EXIT4 INC IND
 BNE EXIT5
 INC IND+1
EXIT5 LDA (IND),Y
 BNE EXIT4
 INC IND
 BNE EXIT6
 INC IND+1
EXIT6 LDA (IND),Y
 BNE EXIT1
EXIT7 LDA MLIERR,Y
 BEQ EXIT8
 JSR OUTDO
 INY
 BNE EXIT7
EXIT8 LDA ERRMLI
 JSR HEXOUT
EXIT0 LDA INDSAV
 STA IND
 LDA INDSAV+1
 STA IND+1
 LDA ASAV
 LDX XSAV
 LDY YSAV
;
; Hier FID-Exit
; =============
;
 RTS
;
INDSAV DB $00
 DB $00
ASAV DB $00
XSAV DB $00
YSAV DB $00
ERROR1 DB $2728
 DB $00
 ASC 'I/O-FEHLER'
 DB $00
 DB $2B
 DB $4E
 DB $00
 ASC 'SCHREIBGESCHUETZT'
 DB $00
 DB $40
 DB $00
 ASC 'ILLEGALER NAME'
 DB $00
 DB $44
 DB $45
 DB $46
 DB $00
 ASC 'NICHT GEFUNDEN'
 DB $00
 DB $47
 DB $57
 DB $00
 ASC 'DOPPELTER NAME'
 DB $00
 DB $48
 DB $49
 DB $00
 ASC 'DISK ODER DIRECTORY VOLL'
 DB $00
 DB $4A
 DB $00
 ASC 'FALSCHER DATEITYP'
 DB $00
 DB $00
MLIERR ASC 'MLI-'
 DB $00
;
; MLI-Befehle
;
RB JSR MLI
 DB $65
 DW RBCNT
 RTS
RBCNT DB $04
;
CR JSR MLI
 DB $C0
 DW CRCNT
 RTS
CRCNT DB $07
CRNAM DW NOM1
CRACC DB $C3
CRTYP DB $00
CRAUX DB $00
 DB $00
CRSTR DB $00
CRCDAT DB $00
 DB $00
CRCUHR DB $00
 DB $00
;
DE JSR MLI
 DB $C1
 DW DECNT
 RTS
DECNT DB $01
DENAM DW NOM1
;
RN JSR MLI
 DB $C2
 DW RNCNT
 RTS
RNCNT DB $02
RNNAM1 DW NOM1
RNNAM2 DW NOM2
;
SF JSR MLI
 DB $C3
 DW SFCNT
 RTS 
SFCNT DB $07
SFNAM DW NOM1
SFACC DB $00
SFTYP DB $00
SFAUX DB $00
 DB $00
SFNUL1 DB $00
SFNUL2 DB $00
 DB $00
SFMDAT DB $00
 DB $00
SFMUHR DB $00
 DB $00
;
GF JSR MLI
 DB $C4
 DW GFCNT
 RTS 
GFCNT DB $0A
GFNAM DW NOM1
GFACC DB $00
GFTYP DB $00
GFAUX DB $00
 DB $00
GFSTR DB $00
GFBLKS DB $00
 DB $00
GFMDAT DB $00
 DB $00
GFMUHR DB $00
 DB $00
GFCDAT DB $00
 DB $00
GFCUHR DB $00
 DB $00
;
OL JSR MLI
 DB $C5
 DW ONCNT
 RTS
ONCNT DB $02
ONUNIT DB $00
ONDPUF DW DPUF
;
SP JSR MLI
 DB $C6
 DW SPCNT
 RTS
SPCNT DB $01
SPNOM0 DW NOM0
;
GP JSR MLI
 DB $C7
 DW GPCNT
 RTS
GPCNT DB $01
GPNOM0 DW NOM0
;
OP JSR MLI
 DB $C8
 DW OPCNT
 RTS
OPCNT DB $03
OPNAM DW NOM1
OPBPUF DW BPUF
OPREF DB $00
;
NL JSR MLI
 DB $C9
 DW NLCNT
 RTS
NLCNT DB $03
NLREF DB $00
NLENAB DB $00
NLCHR DB $00
;
RD JSR MLI
 DB $CA
 DW RDCNT
 RTS
RDCNT DB $04
RDREF DB $00
RDDPUF DB $00
 DB $00
RDREQ DB $00
 DB $00
RDTRA DB $00
 DB $00
;
WR JSR MLI
 DB $CB
 DW WRCNT
 RTS
WRCNT DB $04
WRREF DB $00
WRDPUF DB $00
 DB $00
WRREQ DB $00
 DB $00
WRTRA DB $00
 DB $00
;
CL JSR MLI
 DB $CC
 DW CLCNT
 RTS
CLCNT DB $01
CLREF DB $00
;
GE JSR MLI
 DB $D1
 DW GECNT
 RTS
GECNT DB $02
GEREF DB $00
GEEOF DB $00
 DB $00
 DB $00
;
; Cout- und Prbyte-Ausgabe
;
OUTDO ORA #$80
 BNE OUTCHR
RTNDO LDA #$8D
 BNE OUTCHR
OUTSPC LDA #$A0
OUTCHR JMP COUT
;
; Hex-Word als Dezimalzahl ausgeben
; A, X und Y-Register werden veraendert
;
HEXAX STY HEXAZ 
 STA HEXHH
 STX HEXLL
 LDY #$80
 STY HEDE11
 LDX #0
 LDY #4
HEDE2 LDA #$30 ;'0'
 STA HEDE12
HEDE3 LDA HEXLL
 CMP HEDE8,Y
 LDA HEXHH
 SBC HEDE9,Y
 BCC HEDE4
 STA HEXHH
 LDA HEXLL
 SBC HEDE8,Y
 STA HEXLL
 INC HEDE12
 BNE HEDE3
HEDE4 LDA HEDE12
 INY
 DEY
 BEQ HEDE6
 CMP #$30 ;'0'
 BEQ HEDE5
 STA HEDE11
HEDE5 BIT HEDE11
 BPL HEDE6
 LDA #$30 ;'0', auch Space moeglich
HEDE6 STA HEDE10,X
 INX
 DEY
 BPL HEDE2
 LDY HEXAZ         ;Y=0 fuer mehr als 9999 Blocks
HEDE7 LDA HEDE10,Y ;Y=1 fuer bis zu   9999 Blocks
 JSR OUTDO
 INY
 CPY #5
 BNE HEDE7
 RTS
HEDE8 DB $01 ;<1
 DB $0A ;<10
 DB $64 ;<100
 DB $E8 ;<1000
 DB $10 ;<10000
HEDE9 DB $00 ;>1
 DB $00 ;>10
 DB $00 ;>100
 DB $03 ;>1000
 DB $27 ;>10000
HEDE10 DS 5
HEDE11 DS 1
HEDE12 DS 1
HEXLL DS 1
HEXHH DS 1
HEXAZ DS 1
;
HEXOUT JMP PRBYTE
;
; Reboot
;
REBOOT JMP RB
;
; Online
;
ONLIN LDA #>DPUF
 STA IND
 LDA #<DPUF
 STA IND+1
 LDY #$00
 TYA
ONLIN1 STA (IND),Y
 INY 
 BNE ONLIN1
 JSR OL
 BCC ONLP0
 STA ERRMLI
ONLIN2 JMP EXIT
ONLIN3 LDX NOM0
 BEQ ONLIN2
 JSR RTNDO
 LDY #$00
ONLIN4 INY
 LDA NOM0,Y
 JSR OUTDO
 DEX
 BNE ONLIN4
 BEQ ONLIN2
ONLP0 LDY #$00
 LDA (IND),Y
 BNE ONLP1
 INY
 LDA (IND),Y
 BEQ ONLIN3
ONLP1 JSR RTNDO
 LDY #$00
 LDA #$D3
 JSR OUTDO
 LDA (IND),Y
 AND #$70
 LSR A
 LSR A
 LSR A
 LSR A
 ORA #$B0
 JSR OUTDO
 LDA #$AC
 JSR OUTDO
 LDA (IND),Y
 AND #$0F
 TAX 
 LDA #$C4
 JSR OUTDO
 LDA (IND),Y
 BPL ONLP2
 LDA #$B2
 BNE ONLP3
ONLP2 LDA #$B1
ONLP3 JSR OUTDO
 JSR OUTSPC
 CPX #$00
 BEQ ONLP5
 LDA #$AF
 JSR OUTDO
ONLP4 INY 
 LDA (IND),Y
 JSR OUTDO
 DEX
 BNE ONLP4
 BEQ ONLP6
ONLP5 LDA #$BF
 JSR OUTDO
ONLP6 CLC 
 LDA IND
 ADC #$10
 STA IND
 BCC ONLP0
 INC IND+1
 BNE ONLP0
;
; Prefix
;
PREFX LDA NOM0
 BEQ GETFX
SETFIX JSR SP     ;Getfix und gleich darauf Setfix
 BCC GETFX        ;wegen Partial Prefix!
PREFX1 STA ERRMLI
PREFX2 LDA #$00
 STA NOM0
PREFX3 LDA NOM0
 CMP #$41
 BCS PREFX2
 JMP EXIT
;
GETFX JSR GP
 BCS PREFX1
 JSR RTNDO
 LDY #$00
 LDX NOM0
 BNE GETFX1
 LDA #$BF
 JSR OUTDO
 JMP PREFX3
GETFX1 INY
 LDA NOM0,Y
 JSR OUTDO
 DEX
 BNE GETFX1
 BEQ PREFX3
;
; Catalog
;
CAT LDX NOM1
 BNE CAT1
 LDX NOM0
 BNE CATMV1
 LDA #$81
 STA ERRALL
 BNE CAT4
CATMV1 STX NOM1
 LDY #$00
CATMV2 INY
 LDA NOM0,Y
 STA NOM1,Y
 DEX
 BNE CATMV2
CAT1 JSR GF
 LDA #$4A
 LDX GFTYP
 CPX #$0F
 BNE CAT2
 JSR OP
 BCC CAT5
CAT2 STA ERRMLI
CAT3 JSR CL
CAT4 JMP EXIT
CAT5 LDA OPREF
 STA NLREF
 JSR NL
 BCS CAT2
CAT6 LDA OPREF
 STA RDREF
 LDA #>DPUF
 STA RDDPUF
 LDA #<DPUF
 STA RDDPUF+1
 LDA #>$0200
 STA RDREQ
 LDA #<$0200
 STA RDREQ+1
 JSR RD
 BCS CAT2
 LDA #>DPUF+4
 STA IND
 LDA #<DPUF
 STA IND+1
CAT7 LDY #$00
 LDA (IND),Y
 BEQ CAT15
 AND #$F0
 CMP #$E0
 BCS CAT15
 JSR RTNDO
 LDY #$1E
 LDA (IND),Y
 LDX #$A0
 AND #$C2
 CMP #$C2
 BEQ CAT8
 LDX #$AA
CAT8 TXA
 JSR OUTDO
 LDY #$10
 LDA (IND),Y
 LDX #$04
CAT9 CMP CAT10,X
 BEQ CAT12
 DEX
 BPL CAT9
 LDA #$BF
 BNE CAT13
CAT10 DB $04
 DB $06
 DB $0F
 DB $FC
 DB $FF
CAT11 ASC 'TBDAS'
CAT12 LDA CAT11,X
CAT13 JSR OUTDO
 JSR OUTSPC
 LDY #$13
 LDA (IND),Y
 TAX 
 LDY #$14
 LDA (IND),Y
 LDY #0      ;5-stellig
 JSR HEXAX
 JSR OUTSPC
 LDY #$00
 LDA (IND),Y
 AND #$0F
 TAX
CAT14 INY
 LDA (IND),Y
 JSR OUTDO
 DEX
 BNE CAT14
CAT15 CLC
 LDA IND
 ADC #$27
 STA IND
 LDA IND+1
 ADC #$00
 STA IND+1
 LDA IND
 CMP #$FF
 BEQ CAT16
 JMP CAT7
CAT16 LDA #>DPUF+2
 STA IND
 LDA #<DPUF
 STA IND+1
 LDY #$00
 CLC
 LDA (IND),Y
 INY
 ADC (IND),Y
 BNE CAT19
;
 LDA GFSTR
 CMP #$0F
 BNE CAT18
 JSR RTNDO
 JSR OUTSPC
 JSR OUTSPC
 JSR OUTSPC
 SEC
 LDA GFAUX
 SBC GFBLKS
 TAX
 LDA GFAUX+1
 SBC GFBLKS+1
 LDY #0      ;5-stellig
 JSR HEXAX
 LDY #0
CAT17 LDA CAT20,Y
 BEQ CAT18
 ORA #$80
 JSR OUTDO
 INY
 BNE CAT17 
CAT18 JMP CAT3
CAT19 JMP CAT6
CAT20 ASC ' FREI'
 DB $00
;
; Create
;
CRTYP0 DB $0F
CRSTR0 DB $0D
CREAT LDA NOM0
 BEQ CREAT1
 LDA NOM1
 BEQ CREAT2
 BNE CREAT5
CREAT1 LDA #$81
 BNE CREAT3
CREAT2 LDA #$82
CREAT3 STA ERRALL
CREAT4 JMP EXIT
CREAT5 LDA CRTYP0
 STA CRTYP
 LDA #$00
 STA CRAUX
 LDA #$00
 STA CRAUX+1
 LDX #$03
CREAT6 LDA MLIDAT,X
 STA CRCDAT,X
 DEX
 BPL CREAT6
 LDA CRSTR0
 STA CRSTR
 JSR CR
 BCC CREAT4
 STA ERRMLI
 BCS CREAT4
;
; Delete
;
DELET LDA NOM1
 BNE DELET3
 LDA #$82
 STA ERRALL
DELET1 JMP EXIT
DELET2 STA ERRMLI
 BCS DELET1
DELET3 JSR DE
 BCC DELET1
 BCS DELET2
;
; Lock und Unlock
;
LKUNL LDA NOM1
 BNE LKUNL3
 LDA #$82
 STA ERRALL
 BNE LKUNL2
LKUNL1 STA ERRMLI
LKUNL2 JMP EXIT
LKUNL3 JSR GTST
 BCS LKUNL1
 LDA BEFEHL
 CMP #$07
 BEQ LKUNL5
 LDA SFACC
 AND #$21
LKUNL4 STA SFACC
 JSR SF
 BCS LKUNL1
 BCC LKUNL2
LKUNL5 LDA SFACC
 ORA #$C2
 BNE LKUNL4
GTST JSR GF
 BCS GTST2
 LDA GFACC
 STA SFACC
 LDA GFTYP
 STA SFTYP
 LDA GFAUX
 STA SFAUX
 LDA GFAUX+1
 STA SFAUX+1
 LDX #$03
GTST1 LDA GFMDAT,X
 STA SFMDAT,X
 DEX
 BPL GTST1
GTST2 RTS
;
; Rename
;
RENOM LDA NOM1
 BNE RENOM3
 LDA #$82
RENOM1 STA ERRALL
RENOM2 JMP EXIT
RENOM3 LDA NOM2
 BNE RENOM4
 LDA #$83
 BNE RENOM1
RENOM4 JSR RN
 BCC RENOM2
 STA ERRMLI
 BCS RENOM2
;
; Bsave und Bload fehlen
;
BSAV JMP EXIT
BLOD JMP EXIT
;
;-----------------------------------
;
; Name-Kopier-Unterroutine
;
NOMMV1 LDY #0
NOMMV2 LDA (_T),Y
 CMP #$20
 BEQ NOMMV3
 INY
 STA (_T+2),Y
 CPY #64
 BNE NOMMV2
NOMMV3 TYA
 LDY #0
 STA (_T+2),Y
 RTS
;
; Parameter-Vektoren: (INDIRECT), Y
;
ERRAZ DS 2  ;nachher
ERRMZ DS 2  ;nachher
BEFEZ DS 2
NOM2Z DS 2
NOM1Z DS 2
NOM0Z DS 2  ;nachher
;
; Parameter-Parse-ANFANG
; ======================
;
ANFANG STX _T+10  ;X-Register retten
;
 LDY #5  ;Zeiger in Tabelle kopieren
 LDX #0
PTR LDA (_SP),Y
 STA ERRAZ,X
 INY
 INX
 CPX #12
 BNE PTR
;
 LDA NOM0Z   ;Prefix kopieren
 STA _T
 LDA NOM0Z+1
 STA _T+1
 LDA #>NOM0
 STA _T+2
 LDA #<NOM0
 STA _T+3
 JSR NOMMV1
;
 LDA NOM1Z  ;Name1 kopieren
 STA _T
 LDA NOM1Z+1
 STA _T+1
 LDA #>NOM1
 STA _T+2
 LDA #<NOM1
 STA _T+3
 JSR NOMMV1
;
 LDA NOM2Z   ;Name2 kopieren
 STA _T
 LDA NOM2Z+1
 STA _T+1
 LDA #>NOM2
 STA _T+2
 LDA #<NOM2
 STA _T+3
 JSR NOMMV1
;
; BEFEHL
;
 LDA BEFEZ
 STA _T
 LDA BEFEZ+1
 STA _T+1
 LDY #0
 LDA (_T),Y
 STA BEFEHL
;
; Aufruf von FID
; ==============
;
 JSR ENTRY
;
; Ausgabeparameter kopieren
;
 LDA ERRMZ   ;Error-MLI
 STA _T
 LDA ERRMZ+1
 STA _T+1
 LDY #0
 LDA ERRMLI
 STA (_T),Y
;
 LDA ERRAZ   ;Error-Allgemein
 STA _T
 LDA ERRAZ+1
 STA _T+1
 LDY #0
 LDA ERRALL
 STA (_T),Y
;
 LDA NOM0Z  ;Prefix kopieren
 STA _T
 LDA NOM0Z+1
 STA _T+1
 LDY #0
 LDA #$20   ;erst durch Space loeschen
 STA (_T),Y
 LDX NOM0
 BEQ ENDE ;leer
NOM0K1 LDA ASCII0,Y  ;Ascii von Prefix
 AND #$7F
 STA (_T),Y
 INY
 DEX
 BNE NOM0K1
 LDA #$20          ;Rest mit Spaces fuellen
NOM0K2 CPY #64
 BCS ENDE
 STA (_T),Y
 INY
 BNE NOM0K2
; 
; Parameter-Parse-ENDE
; ====================
;
ENDE LDX _T+10  ;X-Register laden
#
END;

{-------------------------------------------------------}
FUNCTION RDKEY: CHAR;
BEGIN
RDKEY := '1'; {Dummy}
#A
    STX _T       ;X-Register speichern
    JSR $FD0C   ;RDKEY: Tastaturabfrage
    AND #$5F    ;Bit 7 loeschen und klein in gross
    LDY #5
    STA (_SP),Y  ;in LL von C poken
    LDX _T       ;X-Register laden
#
END;

{-------------------------------------------------------}

BEGIN
WRITELN (CHR(12)); {Home}
WRITELN ('PRODOS-FID FUER KYAN 2.0');
WRITELN ('VON U.STIEHL * 10.5.1986');

{Die Parameter muessen initialisiert werden,
 sonst dreht das Assemblerprogramm durch,
 indem es "zufaellige" Zeiger ermittelt}

NAME0[1]   :=  ' ';   NAME1[1] :=  ' ';   NAME2[1] := ' ';
ERRMLI     :=    0;   ERRALL   :=    0;   BEFEHL   :=   0;

AUSWAHL := 'QOPCMDLURSBK'; {siehe unten Menue}

{Prefix vorhanden?}
BEFEHL := 2;
FID (NAME0, NAME1, NAME2, BEFEHL, ERRMLI, ERRALL); 

REPEAT
 WRITELN;
 IF NAME0[1] = ' ' THEN WRITELN (CHR(7), 'PREFIX SETZEN!');
 REPEAT
  {0}  WRITE ('Q QUIT  '  ); {ohne Parameter} 
  {1}  WRITE ('O ONLINE  '); {ohne Parameter}
  {2}  WRITE ('P PREFIX  '); {NAME0 oder Return} WRITELN;
  {3}  WRITE ('C CAT   '  ); {NAME1 oder Return}
  {4}  WRITE ('M MAKEDIR '); {NAME1}
  {5}  WRITE ('D DELETE  '); {NAME1} WRITELN;
  {6}  WRITE ('L LOCK  '  ); {NAME1}
  {7}  WRITE ('U UNLOCK  '); {NAME1}
  {8}  WRITE ('R RENAME  '); {NAME1 und NAME2}
       WRITELN;
 WRITE ('BEFEHL: '); TASTE := RDKEY; WRITELN;
 UNTIL TASTE IN ['Q','O','P','C','M','D','L','U','R'];
 FOR I := 1 TO 12 DO IF AUSWAHL[I] = TASTE THEN BEFEHL := I-1;
 
 IF BEFEHL = 2 THEN BEGIN
  WRITE ('PREFIX: '); READLN (NAME0) END;
 IF BEFEHL = 8 THEN BEGIN
  WRITE ('ALTNAME: '); READLN (NAME1);
  WRITE ('NEUNAME: '); READLN (NAME2) END;
 IF BEFEHL IN [3,4,5,6,7] THEN BEGIN
  WRITE ('NAME: '); READLN (NAME1) END;
 
 FID (NAME0, NAME1, NAME2, BEFEHL, ERRMLI, ERRALL);

 IF (ERRALL > 0) THEN WRITELN;
 IF (ERRALL = 128) THEN WRITE ('ILLEGALER BEFEHL!');
 IF (ERRALL = 129) THEN WRITE ('PREFIX FEHLT!');
 IF (ERRALL = 130) THEN WRITE ('DATEINAME FEHLT!');
 IF (ERRALL = 131) THEN WRITE ('NEUNAME FEHLT');

UNTIL BEFEHL = 0
END.
