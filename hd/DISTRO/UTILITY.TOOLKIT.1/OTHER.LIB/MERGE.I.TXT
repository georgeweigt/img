PROCEDURE MERGE(VAR MERGENAMES:NAMEARRAY; SELECT,FNUM,RLEN,KLEN,OSET,
                        ORDER:INTEGER;KTYPE:FIELD_TYPE);
BEGIN
#A
 STX MGXS
 LDY #10
 LDA (_SP),Y
 STA MGKLEN
 LDY #7         ;ORDER MSB
 LDA (_SP),Y
 STA MGORD
 LDY #1
MG00 EQU *
 STY _T+10
 JSR MGCA       ;ZERO REFERENCE NUMBERS
 LDA #0
 LDY #5
 STA (_T+3),Y
 LDY _T+10
 INY
 CPY #8
 BNE MG00
 JSR MGMP
 LDY #12        ;RLEN LSB
 LDA (_SP),Y
 STA MGRLEN
 INY
 LDA (_SP),Y
 STA MGRLEN+1
 INY            ;FNUM LSB
 LDA (_SP),Y
 STA MGFNUM
 TAY
;
MG0 JSR MGOBA   ;ALLOCATE OPEN FILE BUFFER
 DEY
 BNE MG0
;
;DELETE FILE #6 AND RECREATE IT.
;SAME AS A PASCAL 'REWRITE'
;
 LDY #6
 JSR MGREWR     ;REWRITE FILE Y
 BEQ MG0A       ;NO ERROR ON REWRITE
 LDY #6
 JMP MGABORT
MG0A EQU *
 LDY #6         ;ALWAYS INTERMEDIATE
 JSR MGOBA
 LDA #0
 STA MGRDLN
 STA MGRDLN+1
 LDA MGFNUM
 TAX
MG1 CLC         ;CALC TOTAL RECBUF SIZE
 LDA MGRLEN
 ADC MGRDLN
 STA MGRDLN
 LDA MGRLEN+1
 ADC MGRDLN+1
 STA MGRDLN+1
 DEX
 BNE MG1
;
 LDX MGXS
 DEX
 DEX
 LDA #>MGRDBF
 STA 0,X
 LDA #<MGRDBF
 STA 1,X
 LDA MGRDLN
 LDY MGRDLN+1
 JSR _LIB+$117
 STX MGXS
;
 LDA MGRDBF
 STA _T+11
 LDA MGRDBF+1
 STA _T+12
 LDA #0
 STA _T+10
;
MG2 INC _T+10   ;GIVE EACH FILE PART OF
 LDY _T+10      ;THE RECORD BUFFER
 JSR MGCA
 LDY #3
 LDA _T+11
 STA (_T+3),Y
 INY
 LDA _T+12
 STA (_T+3),Y
 CLC
 LDA MGRLEN
 ADC _T+11
 STA _T+11
 LDA MGRLEN+1
 ADC _T+12
 STA _T+12
 LDA MGFNUM
 CMP _T+10
 BNE MG2
 LDY #5         ;OPEN INTERMED-1
 BNE MG3        ;ALWAYS FIRST TIME
MG4 LDY #0
MG3 INY
 STY _T+10
 JSR MGOPEN
 BEQ MG4A
 LDY _T+10
 JMP MGABORT
MG4A EQU *
 LDY #5
 LDA MGOPL+5
 STA (_T+3),Y   ;REFNUM
 LDY _T+10
 CPY #6         ;FIRST TIME THRU?
 BEQ MG4        ;YES
 CPY MGFNUM
 BNE MG3
 LDA MGFNUM
 STA MGOPCT
 LDY #0
MG5 INY
 JSR MGRR       ;READ REC FROM FILE #Y
 BEQ MG5A
 CMP #$4C       ;EMPTY FILE?
 BEQ MG5B
 JMP MGABORT
MG5B EQU *
 STY _T+1
 JSR MGKILL
 JSR MGCA
 LDY #5
 LDA #0
 STA (_T+3),Y
 DEC MGOPCT
 LDY _T+1
MG5A CPY MGFNUM
 BNE MG5
;
;COMPARE EACH RECORD IN THE
;RECORD BUFFERS ACCORDING TO KEY FIELD
;PARAMETERS.  AN INPUT FILE WILL HAVE A
;REFERENCE NUMBER OF 0 WHEN NO LONGER
;IN NEED OF SERVICE.
;
MG6 EQU *
 LDA MGOPCT
 CMP #1
 BNE MG6C
 JMP MGPURGE
MG6C LDY #0
 STY _T+13
MG6A INY
 JSR MGRF
 CMP #0
 BEQ MG6B       ;SKIP
 TYA            ;RECORD WHICH ELEMENTS
 LDX _T+13
 STA MGRT,X     ;NEED TO BE CHECKED
 INC _T+13
MG6B CPY #5     ;DONE?
 BNE MG6A
MG15 EQU *
 LDA #1
 STA MGCCT      ;NUMBER OF SCANNED RECORDS
 LDA MGRT
 STA MGS1       ;START WITH FIRST IN TABLE
MG9 EQU *
 LDX MGCCT
 INC MGCCT
 LDA MGRT,X
 STA MGS2
 JSR MGCOMP     ;COMPARE RECORDS USING S1,S2
 PHP
 BIT MGORD      ;NEGATIVE IF > TO <
 BMI MG11
 PLP            ;USE INCREASING RECS
 BCC MG10       ;S1<S2 SO DON'T SWAP
 BCS MG12
MG11 EQU *
 PLP
 BCS MG10       ;S1>=S2 SO KEEP IT
MG12 LDA MGS2
 STA MGS1
MG10 EQU *      ;S1 IS RECORD TO KEEP OR WRITE
 LDA MGCCT
 CMP MGOPCT     ;DONE WITH OPEN RECORDS?
 BNE MG9        ;NO
 LDY MGS1
 JSR MGWR       ;RETURN AFTER REPLACEMENT READ
 BEQ MG15       ;SCAN SAME FILES
 CMP #$4C       ;EOF?
 BEQ MG19
 LDY MGS1
 JMP MGABORT
MG19 EQU *
 LDY MGS1
 JSR MGKILL     ;DEALLOCATE THIS FILE
 JSR MGCA
 LDY #5
 LDA #0
 STA (_T+3),Y   ;ZERO FILE'S REFNUM
 DEC MGOPCT
 LDA MGOPCT     ;DONE? (NONE OPEN)
 BEQ MG20       ;YES
 JMP MG6
;
MG20 EQU *      ;NORMAL EXIT HERE
 JSR MGDEA      ;DEALLOCATE READ BUFFER
 JSR MGFIX6     ;FIX EOF MARKER IN FILE 6
 LDY #6
 JSR MGKILL
 LDY #16
 LDA (_SP),Y    ;'SELECT' LSB
 CMP #6
 BNE MG20C
 JMP MG25       ;DONE WITH MERGE
MG20C EQU *
 TAY
 STY MGSEL
 LDY #6
 JSR MGOBA      ;RE-OPEN FILE 6
 JSR MGOPEN
 LDY #5
 LDA MGOPL+5
 STA (_T+3),Y
 LDY MGSEL
 JSR MGREWR     ;ELSE COPY #6 TO #SELECT
 BEQ MG20B
 LDY MGSEL
 JMP MGABORT
MG20B LDY MGSEL
 JSR MGOBA
 JSR MGOPEN
 BEQ MG20A
 LDY MGSEL
 JMP MGABORT
MG20A EQU *     ;COPY FILE 6 TO FILE 'SELECT'
 LDY #5
 LDA MGOPL+5
 STA (_T+3),Y
 LDA MGXS
 STA _T
 JSR FIND_OPEN  ;ALLOCATE 1279 BYTE BUFFER
 LDA _T
 STA MGXS
 LDA OPENSAFE
 STA MGRDL+2
 LDA OPENSAFE+1
 STA MGRDL+3
MG21 EQU *
 LDA #>1279
 STA MGRDL+4
 LDA #<1279
 STA MGRDL+5
 LDY #6
 JSR MGRF
 STA MGRDL+1
 JSR _MLI
 DB  $CA        ;READ FROM FILE 6
 DW  MGRDL
 BEQ MG22
 CMP #$4C
 BEQ MG24       ;NORMAL CLOSE OF COPIED FILES
 LDY #6
 JMP MGABORT
MG22 EQU *
 LDA MGRDL+6    ;WRITE # READ
 STA MGWRL+4
 LDA MGRDL+7
 STA MGWRL+5
 LDY MGSEL
 JSR MGRF
 STA MGWRL+1
 JSR _MLI
 DB  $CB        ;WRITE
 DW  MGWRL
 BEQ MG21
 LDY MGSEL
 JMP MGABORT
MG24 EQU *
 LDY #6
 JSR MGKILL
 LDY MGSEL
 JSR MGKILL
 LDX MGXS
 DEX
 DEX
 LDA #>MGRDL+2
 STA 0,X
 LDA #<MGRDL+3
 STA 1,X
 JSR _LIB+$114  ;DE-ALLOCATE READ BUFFER
 STX MGXS
MG25 EQU *      ;CLOSE INTERMED AND RETURN
 JSR MGRP       ;RESTORE PATHNAMES
 LDX MGXS
#
END;
#A
MGCA EQU *
 TYA
 PHA
 CLC
 LDA #0
MGCA1 EQU *
 DEY
 BEQ MGCA2
 ADC #9
 BNE MGCA1
MGCA2 EQU *
 ADC #>MGRAD
 STA _T+3
 LDA #<MGRAD
 ADC #0
 STA _T+4
 PLA
 TAY
 RTS
;
MGOBA EQU *
 TYA
 PHA
 LDA MGXS
 STA _T
 JSR FIND_OPEN
 LDA _T
 STA MGXS
 PLA
 PHA
 TAY
 JSR MGCA
 LDY #0
 LDA OPENSAFE
 STA (_T+3),Y
 INY
 LDA OPENSAFE+1
 STA (_T+3),Y
 INY
 LDA OPENADR+1
 STA (_T+3),Y
 PLA
 TAY
 RTS
;
MGDEA EQU *
 LDX MGXS
 DEX
 DEX
 LDA #>MGRDBF
 STA 0,X
 LDA #<MGRDBF
 STA 1,X
 JSR _LIB+$114
 STX MGXS
 RTS
;
MGRF EQU *
 TYA
 PHA
 JSR MGCA
 LDY #5
 LDA (_T+3),Y
 TAX
 PLA
 TAY
 TXA
 RTS
;
MGCP EQU *
 TYA
 PHA
 LDY #18
 LDA (_SP),Y
 STA _T+2
 INY
 LDA (_SP),Y
 STA _T+3
 PLA
 PHA
 TAY
MGCP1 EQU *
 DEY
 BEQ MGCP2
 CLC
 LDA _T+2
 ADC #65
 STA _T+2
 LDA _T+3
 ADC #0
 STA _T+3
 JMP MGCP1
MGCP2 EQU *
 PLA
 TAY
 RTS
;
MGMP EQU *
 LDY #7
MGMP1 EQU *
 STY _T+14
 JSR MGCP
 LDY #64
 JSR MPTH1
 LDY #0
 LDA (_T+2),Y
 PHA
 LDA _T+3
 PHA
 LDA _T+2
 PHA
 LDY _T+14
 JSR MGCA
 LDY #6
 PLA
 STA (_T+3),Y
 INY
 PLA
 STA (_T+3),Y
 INY
 PLA
 STA (_T+3),Y
 LDY _T+14
 DEY
 BNE MGMP1
 RTS
;
MGRP EQU *
 LDY #7
MGRP1 EQU *
 STY _T+14
 JSR MGCP
 JSR RESTPATH
 LDY _T+14
 DEY
 BNE MGRP1
 RTS
;
MGKILL EQU *
 TYA
 PHA
 JSR MGRF
 STA MGCLL+1
 JSR _MLI
 DB  $CC
 DW  MGCLL
 JSR MGCA
 LDY #0
 LDA (_T+3),Y
 STA OPENSAFE
 INY
 LDA (_T+3),Y
 STA OPENSAFE+1
 LDX MGXS
 DEX
 DEX
 LDA #>OPENSAFE
 STA 0,X
 LDA #<OPENSAFE
 STA 1,X
 JSR _LIB+$114
 STX MGXS
 PLA
 TAY
 RTS
MGCLL DB 1,0
;
MGRR EQU *
 STY _T+14
 JSR MGCA
 LDY #3
 LDA (_T+3),Y
 STA MGRDL+2
 INY
 LDA (_T+3),Y
 STA MGRDL+3
 INY
 LDA (_T+3),Y
 STA MGRDL+1
 LDA MGRLEN
 STA MGRDL+4
 LDA MGRLEN+1
 STA MGRDL+5
 JSR _MLI
 DB  $CA
 DW  MGRDL
 PHP
 LDY _T+14
 PLP
 RTS
;
MGWR EQU *      ;WRITE RECORD INDEXED BY Y
 JSR MGCA
 LDY #3
 LDA (_T+3),Y   ;REC BUFFER LSB
 STA MGWRL+2
 INY
 LDA (_T+3),Y
 STA MGWRL+3
 LDY #6         ;INTERMED FILE IS DEST
 JSR MGRF
 STA MGWRL+1
 LDA MGRLEN
 STA MGWRL+4
 LDA MGRLEN+1
 STA MGWRL+5
 JSR _MLI
 DB  $CB        ;WRITE
 DW  MGWRL
 BEQ MGWR1
 LDY #6
 JMP MGABORT
MGWR1 EQU *
 LDY MGS1       ;READ NEXT RECORD TO REPLACE
 JMP MGRR       ;ONE JUST WRITTEN
;
MGREWR EQU *    ;CREATE FILE Y
 JSR MGCA
 LDY #6
 LDA (_T+3),Y
 STA _T+5
 STA MGCRTL+1
 INY
 LDA (_T+3),Y
 STA _T+6
 STA MGCRTL+2
 INY
 LDA (_T+3),Y
 LDY #0
 STA (_T+5),Y
 LDA #1
 STA _T+4       ;PARM COUNT IS 1
 JSR _MLI
 DB  $C1        ;DESTROY
 DW  _T+4
 JSR _MLI
 DB  $C0        ;CREATE
 DW  MGCRTL
 RTS
;
MGOPEN EQU *
 JSR MGCA
 LDY #6
 LDA (_T+3),Y
 STA MGOPL+1
 STA _T+7
 INY
 LDA (_T+3),Y
 STA MGOPL+2
 STA _T+8
 INY
 LDA (_T+3),Y
 LDY #0
 STA (_T+7),Y
 LDY #2
 LDA (_T+3),Y
 STA MGOPL+4
 JSR _MLI
 DB  $C8
 DW  MGOPL
 RTS
;
MGFIX6 EQU *
 LDY #6
 JSR MGRF
 STA MGFPL+1
 JSR _MLI
 DB  $CF
 DW  MGFPL
 JSR _MLI
 DB  $D0
 DW  MGFPL
 BEQ MGFIXA
 LDY #6
 JMP MGABORT
MGFIXA RTS
;
MGOPL DB 3
 DW 0,0
 DB 0
MGRDL EQU *
MGWRL DB 4,0
 DW 0,0,0
MGCRTL DB 7
 DW 0
 DB $C3,6,0,0,1
 DW 0,0
MGFPL DB 2,0
 DS 3
MGRDBF DS 2
MGRDLN DS 2
MGRLEN DS 2
MGRT DS 5
MGXS DS 1
MGFNUM DS 1
MGOPCT DS 1
MGCCT DS 1
MGORD DS 1
MGKLEN DS 1
MGSEL DS 1
MGRAD DS 63
MGS1 DS 1
MGS2 DS 1
MGZ1 DS 1
MGZ2 DS 1
;
;
;
MGCOMP EQU *
 LDY MGS1       ;CALC ADDRESS OF KEY FIELDS
 JSR MGCA
 CLC
 LDY #3
 LDA (_T+3),Y   ;BUFFER ADRESS LSB
 LDY #8         ;OFFSET LSB
 ADC (_SP),Y
 STA _T+5
 LDY #4
 LDA (_T+3),Y
 LDY #9
 ADC (_SP),Y
 STA _T+6
;
 LDY MGS2
 JSR MGCA
 CLC
 LDY #3
 LDA (_T+3),Y
 LDY #8
 ADC (_SP),Y
 STA _T+7
 LDY #4
 LDA (_T+3),Y
 LDY #9
 ADC (_SP),Y
 STA _T+8
;
 LDY #5
 LDA (_SP),Y    ;KEY TYPE
 BNE MGC1A
;COMPARE CHARACTERS
 LDY #0
MGC1 EQU *
 LDA (_T+5),Y
 CMP (_T+7),Y
 BNE MGC9       ;EXIT WHEN <>
 INY
 CPY MGKLEN     ;CHECKED ALL?
 BNE MGC1
 BEQ MGC9       ;EXIT W/ N=1
MGC1A CMP #1
 BNE MGC3
;COMPARE INTEGERS
 LDY #0
 LDA (_T+5),Y
 CMP (_T+7),Y
 INY
 LDA (_T+5),Y
 SBC (_T+7),Y
MGC9 RTS
;
MGC3 EQU *
 JSR MGCHKZ     ;ADJUST ZEROS IF PRESENT
 LDY #0
 LDA (_T+7),Y   ;SIGN OF S2
 AND #$20       ;STRIP ALL BUT BIT 5
 STA _T+4
 LDA (_T+5),Y   ;SIGN OF S1
 AND #$20
 CMP _T+4
 BNE MGC3R
;
 LDA (_T+5),Y   ;EXP SIGN OF S1
 AND #$10
 STA _T+1
 LDA (_T+7),Y   ;EXP SIGN OF S2
 AND #$10
 CMP _T+1
 BNE MGC3R
;
 LDY #7
 LDA (_T+7),Y   ;EXP OF S2
 STA _T+2
 LDA (_T+5),Y   ;EXP OF S1
 STA _T+3
 LDA _T+1
 BEQ MGC3A
 LDA _T+2
 EOR #$FF
 STA _T+2
 LDA _T+3
 EOR #$FF
 STA _T+3
;
MGC3A EQU *
 LDA _T+3
 CMP _T+2
 BNE MGC3R
;
 LDY #0
 LDA (_T+7),Y
 AND #15        ;1ST SIG DIGIT
 STA _T+1
 LDA (_T+5),Y
 AND #15
 STA _T+2
 LDA _T+4
 BEQ MGC3B
 LDA _T+1
 EOR #$FF
 STA _T+1
 LDA _T+2
 EOR #$FF
 STA _T+2
;
MGC3B EQU *
 LDA _T+2
 CMP _T+1
 BEQ MGC3R
;
 LDY #1         ;CHECK REST OF SIG DIGITS
MGC3C EQU *
 LDA (_T+5),Y   ;S1
 STA _T+1
 LDA (_T+7),Y
 STA _T+2
 LDA _T+4
 BEQ MGC3D
 LDA _T+1
 EOR #$FF
 STA _T+1
 LDA _T+2
 EOR #$FF
 STA _T+2
;
MGC3D EQU *
 LDA _T+1
 CMP _T+2
 BNE MGC3R
 INY
 CPY #7         ;DONE?
 BNE MGC3C
MGC3R EQU *     ;SAVE STATUS, CHECK ZEROES
 PHP            ;AND RETURN TO CALLER
 LDA MGZ1
 BEQ MGC3R1
 LDY #7
 LDA #0
MG3CR3 EQU *
 STA (_T+5),Y   ;RESTORE S1
 DEY
 BPL MG3CR3
MGC3R1 EQU *
 LDA MGZ2
 BEQ MGC3R2
 LDY #7
 LDA #0
MG3CR4 EQU *
 STA (_T+7),Y
 DEY
 BPL MG3CR4
MGC3R2 EQU *
 PLP
 RTS
;
MGCHKZ EQU *
 LDY #0
 STY MGZ1
 STY MGZ2
MGCHZ1 EQU *
 LDA (_T+5),Y
 BNE MGCHZ2
 INY
 CPY #8
 BNE MGCHZ1
 INC MGZ1
 LDA #$10
 LDY #0
 STA (_T+5),Y
 LDA #$99
 LDY #7
 STA (_T+5),Y
;
MGCHZ2 EQU *
 LDY #0
MGCHZ3 EQU *
 LDA (_T+7),Y
 BNE MGCHZ4
 INY
 CPY #8
 BNE MGCHZ3
 INC MGZ2
 LDA #$10
 LDY #0
 STA (_T+7),Y
 LDA #$99
 LDY #7
 STA (_T+7),Y
MGCHZ4 EQU *
 RTS
;
MGPURGE EQU *
 LDY #0
MGP1 EQU *
 INY
 JSR MGRF
 CMP #0
 BEQ MGP1
 STY MGS1
MGP2 EQU *
 LDY MGS1
 JSR MGWR
 BEQ MGP2
 CMP #$4C
 BEQ MGP3
 LDY MGS1
 JMP MGABORT
MGP3 LDY MGS1
 JSR MGKILL
 JMP MG20       ;EXIT NORMALLY
;
;
;
MGABORT EQU *
 STA _T         ;MLI ERROR CODE
 STY _T+1       ;INDEX TO PATHNAME
 LDX #>MGTXT2
 LDY #<MGTXT2
 JSR MGSTROUT
 LDA _T
 JSR $FDDA
 LDX #>MGTXT3
 LDY #<MGTXT3
 JSR MGSTROUT
 LDY _T+1       ;INDEX OF PATHNAME
 JSR MGCA
 LDY #6
 LDA (_T+3),Y
 STA _T+7
 INY
 LDA (_T+3),Y
 STA _T+8
 INY
 LDA (_T+3),Y
 TAY            ;Y=LENGTH OF PATHNAME
 INY
 LDA #0
 STA (_T+7),Y
 INC _T+7
 BNE *+4
 INC _T+8
 LDX _T+7
 LDY _T+8
 JSR MGSTROUT
 LDA #'"+$80
 JSR $FDED
 LDA #13
 JSR $FDED
 JMP _QUIT
;
MGTXT2 EQU *
 DB 13
 ASC 'PRODOS ERROR $'
 DB 0
MGTXT3 EQU *
 ASC ' HAS OCCURRED DURING'
 DB 13
 ASC 'MERGE OF FILE "'
 DB 0
;
MGSTROUT EQU *
 STX _T+10
 STY _T+11
 LDY #0
MGSTR1 EQU *
 LDA (_T+10),Y
 BEQ MGSTR2
 ORA #$80
 JSR $FDED
 INY
 BNE MGSTR1
MGSTR2 EQU *
 RTS
;
;
;
 IFNDEF FIND_OPEN
FIND_OPEN EQU * ;ALLOCATE OPEN FILE BUFFER
 LDX _T
 DEX
 DEX
 LDA #>OPENSAFE
 STA 0,X
 LDA #<OPENSAFE
 STA 1,X
 LDA #>1279
 LDY #<1279
 JSR _LIB+$117
 LDA OPENSAFE+1
 STA OPENADR+1
 LDA OPENSAFE
 STA OPENADR
 BEQ ALCOP9     ;BUFFER ON PAGE BOUNDARY
 INC OPENADR+1
 LDA #0
 STA OPENADR
ALCOP9 EQU *    ;A IS ALWAYS ZERO
 LDY OPENADR+1
 STX _T
 RTS            ;RETURN WITH BUFFER @(A,Y)
OPENADR  DW 0   ;ADDRESS OF BUFFER ON PAGE BOUNDARY
OPENSAFE DW 0   ;ADDRESS OF ACTUAL BUFFER START FOR DISPOSE
;
FREE_OPEN EQU *  ;FREE OPEN BUFFER FROM GLOBAL
 LDX _T
 DEX
 DEX
 LDA #>OPENSAFE
 STA 0,X
 LDA #<OPENSAFE
 STA 1,X
 JSR _LIB+$114
 STX _T
 RTS
;
CLOSE_FILE EQU *
 STA CL_XTRA+1
 JSR _MLI
 DB  $CC
 DW  CL_XTRA
 RTS
CL_XTRA DB 1,0
 ENDIF
;
;
 IFNDEF MAKEPATH
MAKEPATH EQU *
 LDA (_SP),Y    ;ADDRESS OF STRING ADDRESS
 STA _T+2
 INY
 LDA (_SP),Y
 STA _T+3
 LDY #64
MPTH1 LDA (_T+2),Y
 CMP #$20       ;SPACE?
 BNE MPTH2      ;NO. FOUND LAST CHAR OF PATHNAME
 DEY
 BPL MPTH1
 INY            ;Y=0
 TYA
 STA (_T+2),Y   ;MAKE LENGTH ZERO
 RTS
MPTH2 INY       ;PATH LENGTH
 STY PLENX
 DEY
MPTH3 LDA (_T+2),Y
 INY
 STA (_T+2),Y    ;MOVE STRING FORWARD ONE BYTE
 DEY
 DEY
 BPL MPTH3
 INY            ;Y=0
 LDA PLENX
 STA (_T+2),Y
 RTS
PLENX DS 1
 ENDIF
;
 IFNDEF RESTPATH
RESTPATH EQU *  ;RESTORE PATH @(_T+2)
 LDY #0
 LDA (_T+2),Y   ;LENGTH
 STA PLENX
 INY
RPTH1 LDA (_T+2),Y
 DEY
 STA (_T+2),Y   ;MOVE STRING BACK ONE BYTE
 INY
 INY
 DEC PLENX
 BPL RPTH1
 RTS
 ENDIF
#
