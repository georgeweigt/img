PROCEDURE ESORT;

(* GLOBAL INPUTS:
        FYLE    : FILE TO BE SORTED
        RLEN    : RECORD LENGTH
        OSET    : BYTE OFFSET FROM START OF
                  RECORD TO KEY
        ORDER   : 0 OR +   IF ASCENDING
                  NEGATIVE IF DESCENDING
        KLEN    : KEY FIELD LENGTH IN BYTES
        KTYPE   : TYPE OF KEY FIELD
                  ALPHA_FIELD, INTEGER_FIELD,
                  OR REAL_FIELD             *)

CONST
   MAXBYTES     = 5000; (* MAX NUMBER OF BYTES IN ARRAYA *)
   MAXRECORDS   = 1000; (* MAX NUMBER OF RECORDS TO LOAD *)

TYPE
   NODEPTR      = ^NODE;
   NODE         = RECORD
                     INDEXA   : INTEGER;
                     NEXTNODE : NODEPTR
                  END;

VAR
   ARRAYA       : ARRAY [1..MAXBYTES] OF CHAR;
   BASE,CURRENT,
   TARGET       : NODEPTR;
   FYLELIST     : NAMEARRAY;
   I,J,F,G,     (* F AND G ARE REFERENCE NUMBERS FOR I/O ROUTINES *)
   RECLIMIT,    (* NUMBER OF RECORDS WHICH FILL ARRAYA *)
   KEYLENGTH,   (* ACTUAL LENGTH OF KEY FIELD IN BYTES *)
   RECNUMBER,   (* NUMBER OF RECORDS READ SO FAR *)
   SORTORDER,   (* ORDER OF SORT (-1,0,1) *)
   FILEINDEX,   (* INDEX TO FYLELIST PATHLIST *)
   NEXTPOINTER  : INTEGER;
   DOINGPURGE,
   FOUND_EOF,
   NEEDNEWFILE  : BOOLEAN;


(************************************************
   THESE ROTINES PROVIDE PROGRAMMERS
   WITH FIVE MACHINE CODE ROUTINES:
        OPENFILE
        CLOSEFILE
        READBYTE
        WRITEBYTE
        MAKETXT
   EACH CAN BE USED SEPERATELY OR IN
   CONJUNCTION WITH EACH OTHER.
   BE SURE TO READ THE REMARKS IN EACH
   ROUTINE BEFORE USING ANY OF THE
   FOLLOWING CODE IN ANOTHER APPLICATION:   *)



FUNCTION OPENFILE(VAR PATHNAME:PATHSTRING):INTEGER;
(* RETURNS REFERENCE NUMBER OF FILE OPENED.
   A ZERO IS RETURNED IF AN ERROR OCCURS
   THIS FUNCTION ACTS AS A "RESET" PROCEDURE *)
VAR RESULT:INTEGER;
BEGIN
#A
 STX _T
 LDY #9
 JSR MAKEPATH   ;CONVERT STRING TO PATHNAME
 JSR FIND_OPEN  ;ALLOCATE PAGE ALIGNED BUFFER
 STA _T+4
 STY _T+5
 LDA #3
 STA _T+1
 LDA #0
 STA _T+6       ;ZERO REF IN CASE OF ERROR
 JSR _MLI
 DB  $C8        ;OPEN
 DW  _T+1
 LDA _T+6       ;REFNUM
 PHA
 BNE OPEN1      ;NO ERROR
 JSR FREE_OPEN  ;ERROR SO GIVE MAKE MEMORY
 PLA
 JMP OPEN9      ;AND EXIT
OPEN1 EQU *
 TAY
 DEY            ;INDEX TO TABLE OF BUFFER ADDRESSES
 TYA
 ASL            ;*2
 TAY
 LDA OPENSAFE
 STA OPENBUF,Y
 LDA OPENSAFE+1
 STA OPENBUF+1,Y
 PLA
OPEN9 EQU *
 LDY #5         ;RETURN REFNUM
 STA (_SP),Y
 LDA #0
 INY
 STA (_SP),Y
 JSR RESTPATH
 LDX _T
#
 OPENFILE:=RESULT
END;
#A
;
OPENBUF DS 16
;
 IFNDEF FIND_OPEN
FIND_OPEN EQU * ;ALLOCATE OPEN FILE BUFFER
 LDX _T
 DEX
 DEX
 LDA #>OPENSAFE
 STA 0,X
 LDA #<OPENSAFE
 STA 1,X
 LDA #>1279     ;1024+255
 LDY #<1279
 JSR _LIB+$117
 LDA OPENSAFE+1
 STA OPENADR+1
 LDA OPENSAFE
 STA OPENADR
 BEQ ALCOP9     ;BUFFER ON PAGE BOUNDARY
 INC OPENADR+1
 LDA #0
 STA OPENADR
ALCOP9 EQU *    ;A IS ALWAYS ZERO
 LDY OPENADR+1
 STX _T
 RTS            ;RETURN WITH BUFFER @(A,Y)
OPENADR  DW 0   ;ADDRESS OF BUFFER ON PAGE BOUNDARY
OPENSAFE DW 0   ;ADDRESS OF ACTUAL BUFFER START FOR DISPOSE
;
FREE_OPEN EQU *  ;FREE OPEN BUFFER FROM GLOBAL
 LDX _T
 DEX
 DEX
 LDA #>OPENSAFE
 STA 0,X
 LDA #<OPENSAFE
 STA 1,X
 JSR _LIB+$114
 STX _T
 RTS
;
CLOSE_FILE EQU *
 STA CL_XTRA+1
 JSR _MLI
 DB  $CC
 DW  CL_XTRA
 RTS
CL_XTRA DB 1,0
 ENDIF
;
;
;
 IFNDEF MAKEPATH
MAKEPATH EQU *
 LDA (_SP),Y    ;ADDRESS OF STRING ADDRESS
 STA _T+2
 INY
 LDA (_SP),Y
 STA _T+3
 LDY #64
MPTH1 LDA (_T+2),Y
 CMP #$20       ;SPACE?
 BNE MPTH2      ;NO. FOUND LAST CHAR OF PATHNAME
 DEY
 BPL MPTH1
 INY            ;Y=0
 TYA
 STA (_T+2),Y   ;MAKE LENGTH ZERO
 RTS
MPTH2 INY       ;PATH LENGTH
 STY PLENX
 DEY
MPTH3 LDA (_T+2),Y
 INY
 STA (_T+2),Y    ;MOVE STRING FORWARD ONE BYTE
 DEY
 DEY
 BPL MPTH3
 INY            ;Y=0
 LDA PLENX
 STA (_T+2),Y
 RTS
PLENX DS 1
 ENDIF
;
 IFNDEF RESTPATH
RESTPATH EQU *  ;RESTORE PATH @(_T+2)
 LDY #0
 LDA (_T+2),Y   ;LENGTH
 STA PLENX
 INY
RPTH1 LDA (_T+2),Y
 DEY
 STA (_T+2),Y   ;MOVE STRING BACK ONE BYTE
 INY
 INY
 DEC PLENX
 BPL RPTH1
 RTS
 ENDIF
#



FUNCTION CREATEFILE(VAR PATHNAME:PATHSTRING):INTEGER;
(* RETURNS REFERENCE NUMBER OF FILE CREATED.
   IF IT EXISTS, THE FILE IS DELETED AND REPLACED
   WITH A NEW, EMPTY ONE.  A ZERO IS RETURNED IF
   AN ERROR OCCURS.  THIS FUNCTION ACTS AS A
   "REWRITE" PROCEDURE.
   **** NOTE: 'CREATEFILE' MUST FIND 'OPENFILE'
   IN THE PASCAL HOST PROGRAM!!!!!!!!!     *)
BEGIN
#A
 STX _T
 LDY #7
 JSR MAKEPATH
 LDA #1
 STA _T+1
 JSR _MLI
 DB  $C1        ;DESTROY
 DW  _T+1
 LDA _T+2
 STA CRL+1
 LDA _T+3
 STA CRL+2
 JSR _MLI
 DB  $C0        ;CREATE
 DW  CRL
 JSR RESTPATH
 LDX _T
#
 CREATEFILE:=OPENFILE(PATHNAME)
END;
#A
CRL EQU *
 DB 7
 DW 0
 DB $C3,6,0,0,1
 DW 0,0
#



PROCEDURE CLOSEFILE(REFNUM:INTEGER);
(* CLOSE FILE ACCORDING TO REFERENCE NUMBER
   AND RE-ALLOCATE OPEN BUFFER SPACE IN HEAP *)
BEGIN
#A
 STX _T
 LDY #5
 LDA (_SP),Y
 PHA
 TAY
 DEY
 TYA
 ASL            ;INDEX TO MEMORY TO DEALLOCATE
 TAY
 LDA OPENBUF,Y
 STA OPENSAFE
 LDA OPENBUF+1,Y
 STA OPENSAFE+1
 JSR FREE_OPEN
 PLA
 JSR CLOSE_FILE
 LDX _T
#
END;



FUNCTION READBYTE(REFNUM:INTEGER; VAR BYTELOADED:CHAR):BOOLEAN;
(* RETURN NEXT BYTE FROM FILE WITH REFNUM.
   RETURNS TRUE IF EOF ENCOUNTERED *)
VAR RESULT:BOOLEAN;
BEGIN
#A
 STX _T
 LDY #9
 LDA (_SP),Y
 STA _T+2
 LDA #4
 STA _T+1
 LDY #7         ;ADDRESS OF CHAR
 LDA (_SP),Y
 STA _T+3
 INY
 LDA (_SP),Y
 STA _T+4
 LDX #1
 STX _T+5       ;READ ONE BYTE
 DEX
 STX _T+6
 JSR _MLI
 DB  $CA        ;READ
 DW  _T+1
 BEQ REBYT9
 LDA #1         ;ANY ERROR IS EOF
REBYT9 EQU *
 LDY #5
 STA (_SP),Y
 LDX _T
#
 READBYTE:=RESULT
END;



PROCEDURE WRITEBYTE(REFNUM:INTEGER; VAR BYTEWRITTEN:CHAR);
(* WRITE CHAR PASSED INTO FILE REFNUM *)
BEGIN
#A
 STX _T
 LDY #7         ;REFNUM
 LDA (_SP),Y
 STA _T+2
 LDA #4
 STA _T+1
 LDY #5
 LDA (_SP),Y
 STA _T+3
 INY
 LDA (_SP),Y
 STA _T+4
 LDX #1         ;WRITE ONE BYTE
 STX _T+5
 DEX
 STX _T+6
 JSR _MLI
 DB  $CB        ;WRITE
 DW  _T+1
 LDX _T
#
END;



PROCEDURE ESORT_DELETE(VAR PATHNAME:PATHSTRING);
(* THIS CODE IS THE SAME AS THE PRODOS UTILITIES
   'DELETE' FUNCTION, BUT IT DOES NOT RETURN
   ANY POSSIBLE MLI ERROR CODES *)
BEGIN
#A
 STX _T
 LDY #5
 JSR MAKEPATH
 LDA #1
 STA _T+1
 JSR _MLI
 DB $C1
 DW _T+1
 JSR RESTPATH
 LDX _T
#
END;



PROCEDURE MAKETXT(VAR PATHNAME:PATHSTRING);
(* CHANGE THE TYPE OF THE PATHNAME PASSED
   TO 'TXT'.  THIS ROUTINE IS USED WHEN
   CHANGING OVER GENERIC PASCAL DATA FILES
   INTO A TXT FILE (FILE OF CHAR)   *)
BEGIN
#A
 STX _T
 LDY #5
 JSR MAKEPATH
 LDA _T+2
 STA MTXTL+1
 LDA _T+3
 STA MTXTL+2
 LDA #10        ;PARM COUNT
 STA MTXTL
 JSR _MLI
 DB  $C4        ;GET_FILE_INFO
 DW  MTXTL
 LDA #4         ;TXT
 STA MTXTL+4
 LDA #7
 STA MTXTL
 JSR _MLI
 DB  $C3
 DW  MTXTL
 LDX _T
#
END;
#A
MTXTL EQU *
 DS 18
#


PROCEDURE INIT_ESORT_VARS;
BEGIN
   DOINGPURGE:=FALSE;
   NEEDNEWFILE:=FALSE;
   FILEINDEX:=1;
   CASE KTYPE OF
      ALPHA_FIELD   : KEYLENGTH:=KLEN;
      INTEGER_FIELD : KEYLENGTH:=2;
      REAL_FIELD    : KEYLENGTH:=8
   END;
   RECLIMIT := MAXBYTES DIV RLEN;
   IF RECLIMIT > MAXRECORDS THEN RECLIMIT:=MAXRECORDS;
   BASE:=NIL;
   TARGET:=BASE;
   RECNUMBER  :=1;
   NEXTPOINTER:=1;
   IF ORDER < 0 THEN SORTORDER:=-1
                ELSE SORTORDER:=1
END;


PROCEDURE NAME_TEMP_FILES;
(* APPEND SUFFIXES TO FILES IN FYLELIST .1 THRU .6 *)
VAR I,J:INTEGER;
BEGIN
   I:=1;
   REPEAT I:=I+1 UNTIL ((FYLE[I]=' ') OR (I=62));
   FOR J:=1 TO 6 DO
   BEGIN
      FYLELIST[J]:=FYLE;
      FYLELIST[J][I]:='.';
      FYLELIST[J][I+1]:=CHR(J+ORD('0'))
   END;
   FYLELIST[7]:=FYLE
END;


FUNCTION COMPARE(FIRST,SECOND:NODEPTR):INTEGER;
(* FIRST,SECOND POINT TO NODES WHICH
   CONTAIN THE INDEXES TO RECORD DATA
   IN ARRAYA.
   FUNCTION RETURNS -1 IF FIRST<SECOND
                     0 IF FIRST=SECOND
                     1 IF FIRST>SECOND
   FUNCTION VALUE IS REVERSED BY 'ORDER' *)
TYPE
   KEYRECTYPE   = RECORD
                     CASE FIELD_TYPE OF
                      ALPHA_FIELD  :(CVALUE:ARRAY[1..255] OF CHAR);
                      INTEGER_FIELD:(IVALUE:INTEGER);
                      REAL_FIELD   :(RVALUE:INTEGER)
                  END;
VAR I,RESULT :INTEGER;
    FIRSTKEY,
    SECONDKEY:KEYRECTYPE;
    DONE     :BOOLEAN;
BEGIN
   FOR I:=0 TO KEYLENGTH-1 DO
   BEGIN
      FIRSTKEY.CVALUE[I+1] :=ARRAYA[FIRST^.INDEXA +I+OSET];
      SECONDKEY.CVALUE[I+1]:=ARRAYA[SECOND^.INDEXA+I+OSET];
   END;
   CASE KTYPE OF
     ALPHA_FIELD :
     BEGIN
        I:=0;
        REPEAT
           I:=I+1;
           IF FIRSTKEY.CVALUE[I]<SECONDKEY.CVALUE[I]
                THEN RESULT:=-1
                ELSE
           IF FIRSTKEY.CVALUE[I]=SECONDKEY.CVALUE[I]
                THEN RESULT:=0
                ELSE RESULT:=1
        UNTIL (RESULT<>0) OR (I=KLEN);
     END;  (* CASE ALPHA_FIELD *)
     INTEGER_FIELD :
     BEGIN
        IF FIRSTKEY.IVALUE<SECONDKEY.IVALUE
                THEN RESULT:=-1
                ELSE
        IF FIRSTKEY.IVALUE=SECONDKEY.IVALUE
                THEN RESULT:=0
                ELSE RESULT:=1
     END;
     REAL_FIELD :
     BEGIN
        IF FIRSTKEY.RVALUE<SECONDKEY.RVALUE
                THEN RESULT:=-1
                ELSE
        IF FIRSTKEY.RVALUE=SECONDKEY.RVALUE
                THEN RESULT:=0
                ELSE RESULT:=1
     END
   END;  (* CASE *)
   COMPARE := SORTORDER * RESULT
END;


PROCEDURE INSERTNODE;
VAR TRAILER,LEADER:NODEPTR;
    DONE:BOOLEAN;
BEGIN
   IF BASE=NIL THEN BASE:=CURRENT
   ELSE
   BEGIN
      IF COMPARE(CURRENT,BASE)=-1
      THEN BEGIN
              CURRENT^.NEXTNODE:=BASE;
              BASE:=CURRENT
           END
      ELSE
      BEGIN
         LEADER:=BASE;
         REPEAT
            TRAILER:=LEADER;
            LEADER:=LEADER^.NEXTNODE;
            DONE:=(LEADER=NIL);
            IF NOT DONE THEN DONE:=(COMPARE(LEADER,CURRENT)=1)
         UNTIL DONE;
         TRAILER^.NEXTNODE:=CURRENT;
         CURRENT^.NEXTNODE:=LEADER;
         LEADER:=CURRENT
      END
   END
END;


PROCEDURE REMOVENODE;
VAR WALKER:NODEPTR;
BEGIN
   IF TARGET=BASE THEN BASE:=BASE^.NEXTNODE
   ELSE
   BEGIN
      WALKER:=BASE;
      WHILE WALKER^.NEXTNODE<>TARGET DO
         WALKER:=WALKER^.NEXTNODE;
      WALKER^.NEXTNODE:=TARGET^.NEXTNODE
   END;
END;


PROCEDURE WRITENODE;
VAR I        :INTEGER;
    OLDTARGET:NODEPTR;
BEGIN
   IF TARGET=NIL THEN TARGET:=BASE;
   NEXTPOINTER:=TARGET^.INDEXA;
   FOR I:=NEXTPOINTER TO NEXTPOINTER+RLEN-1 DO
      WRITEBYTE(G,ARRAYA[I]);
   IF NOT DOINGPURGE THEN REMOVENODE;
   OLDTARGET:=TARGET;
   TARGET:=TARGET^.NEXTNODE;
   DISPOSE(OLDTARGET);
   NEEDNEWFILE:=(TARGET=NIL);
   (* TARGET=NIL WHEN AT END OF LIST *)
END;


PROCEDURE GETNODE;
(* READ NODE FROM FYLE, PUTTING DATA INTO ARRAYA
   STARTING AT 'NEXTPOINTER' *)
VAR I:INTEGER;
   CH:CHAR;
BEGIN
   I:=0;
   REPEAT
      FOUND_EOF:=READBYTE(F,CH);
      ARRAYA[NEXTPOINTER+I]:=CH;
      I:=I+1
   UNTIL FOUND_EOF OR (I=RLEN);
   IF NOT FOUND_EOF THEN
   BEGIN
      NEW(CURRENT);
      CURRENT^.INDEXA:=NEXTPOINTER;
      CURRENT^.NEXTNODE:=NIL;
      INSERTNODE;
      IF RECNUMBER=RECLIMIT THEN WRITENODE
      ELSE
      BEGIN
         (* ARRAY ISN'T FULL YET SO LINEAR ALLOCATION IS OK *)
         RECNUMBER  :=RECNUMBER+1;
         NEXTPOINTER:=NEXTPOINTER+RLEN
      END
   END;
END;


PROCEDURE PURGE;
VAR MARKER,OLDTARGET:NODEPTR;
BEGIN
   DOINGPURGE:=TRUE;
   MARKER:=TARGET;
   WHILE TARGET<>NIL DO WRITENODE;
   CLOSEFILE(G);
   IF FILEINDEX=5 THEN
   BEGIN
      MERGE(FYLELIST,1,5,RLEN,KLEN,OSET,ORDER,KTYPE);
      FILEINDEX:=1;
   END;
   FILEINDEX:=FILEINDEX+1;
   G:=CREATEFILE(FYLELIST[FILEINDEX]);
   TARGET:=BASE;
   WHILE TARGET<>MARKER DO WRITENODE;
   CLOSEFILE(G);
END;


BEGIN
   INIT_ESORT_VARS;
   NAME_TEMP_FILES;
   F:=OPENFILE(FYLE);
   G:=CREATEFILE(FYLELIST[1]);
   REPEAT
      GETNODE;
      IF NEEDNEWFILE THEN
      BEGIN
         CLOSEFILE(G);
         IF FILEINDEX=5 THEN
         BEGIN
            MERGE(FYLELIST,1,5,RLEN,KLEN,OSET,ORDER,KTYPE);
            FILEINDEX:=1
         END;
         FILEINDEX:=FILEINDEX+1;
         G:=CREATEFILE(FYLELIST[FILEINDEX])
      END
   UNTIL FOUND_EOF;
   PURGE;
   CLOSEFILE(F);
   MERGE(FYLELIST,7,FILEINDEX,RLEN,KLEN,OSET,ORDER,KTYPE);
   FOR I:=1 TO 6 DO ESORT_DELETE(FYLELIST[I]);
   IF KTYPE=ALPHA_FIELD THEN MAKETXT(FYLE)
END;
